// © Все права на распространение и модификацию модуля принадлежат ООО "АКИП" (www.akitorg.ru)
//______________________________________________________________________________

// Получает ключ доступа из хранилищ настроек
//
// Возвращаемое значение:
// Неопределено, пустая структура - если ключ доступа еще не был записан.
// Структура - ключ: "Токен", значение: ключ доступа.
//
Функция ПолучитьПараметрыПодключения() Экспорт
	
	Попытка
		ПараметрыПодключения = ХранилищеОбщихНастроек.Загрузить( "AkiTorgPrintSale", "ПараметрыПодключения",, "AkiTorgPrintSale");
	Исключение
		Попытка
			ПараметрыПодключения = ХранилищеОбщихНастроек.Загрузить( "AkiTorgPrintSale", "ПараметрыПодключения",,);
		Исключение;
			Возврат Неопределено;
		КонецПопытки;
	КонецПопытки;
	
	Если ПараметрыПодключения = Неопределено Тогда
		Возврат Новый Структура;
	Иначе
		Возврат ПараметрыПодключения.Получить();
	КонецЕсли;
	
КонецФункции // ПолучитьПараметрыПодключения

// Записывает ключ доступа в хранилище настроек
// 
// Параметры:
// ПараметрыПодключения - Структура - ключ: "Токен", значение: ключ доступа.
//
Процедура ЗаписатьПараметрыПодключения( ПараметрыПодключения) Экспорт
	
	Попытка
		ХранилищеОбщихНастроек.Сохранить( "AkiTorgPrintSale", "ПараметрыПодключения", Новый ХранилищеЗначения( ПараметрыПодключения, Новый СжатиеДанных(9)),, "AkiTorgPrintSale");
	Исключение
		ХранилищеОбщихНастроек.Сохранить( "AkiTorgPrintSale", "ПараметрыПодключения", Новый ХранилищеЗначения( ПараметрыПодключения, Новый СжатиеДанных(9)));	
	КонецПопытки;

КонецПроцедуры // ЗаписатьПараметрыПодключения

// Удаляет из строки нечитаемые символы, привод к требуемой длине
// 
// Параметры:
// Стр - строка - Разбираемая строка.
// ОграничитьДлину - число - Требуемая длина строки. По умолчанию 100 символов.
//
// Возвращаемое значение:
// Строка - требуемая строка.
//
Функция УдалениеНечитаемыхСимволов( Знач Стр, ОграничитьДлину = 100) Экспорт
	
	Стр = СокрЛП( Стр);
	
	СоответствиеНайден = Новый Соответствие;
	
	Для НомерСимвола = 1 по СтрДлина( Стр) Цикл
		
		ТекСимвол = Сред( Стр, НомерСимвола, 1);
		
		Если КодСимвола( ТекСимвол) < 32 И КодСимвола( ТекСимвол) <> 10 Тогда
			СоответствиеНайден.Вставить( ТекСимвол, "");
		КонецЕсли;
		
	КонецЦикла; // НомерСимвола = 1 по СтрДлина( Стр)
	
	Если СоответствиеНайден.Количество() > 0 Тогда
		Для Каждого ТекСимвол из СоответствиеНайден Цикл
			Стр = СтрЗаменить( Стр, ТекСимвол.Ключ, "");
		КонецЦикла;
	КонецЕсли; // ФлагНайден > 0
	
	Если СтрДлина( Стр) > ОграничитьДлину Тогда
		Стр = Лев( Стр, ОграничитьДлину);
	КонецЕсли;
	
	Возврат Стр;
	
КонецФункции // УдалениеНечитаемыхСимволов

// Записывает событие в журнал регистрации
Функция ЗаписатьСообщение( Сообщение, Событие)
	
	ЗаписьЖурналаРегистрации( Событие,,,, Сообщение);
	Возврат Метаданные.Синоним + " ("+Метаданные.Версия+")";
	
КонецФункции // ЗаписатьСообщение

// Сообщает запись журнала
Процедура СообщитьЗаписьЖурнала( ПараметрыПодключения, ТекстСообщения = "", ПлюсЗапись = "", Событие = "AkiTorgPrintSale: Ошибка", ТекстВерсия = "", ТекстНачало = "") Экспорт
	
	Если НЕ ПустаяСтрока( ТекстСообщения) Тогда
		Сообщить( ТекстСообщения);
	КонецЕсли;
	
	МассивПараметров = Новый Массив;
	
	МассивПараметров.Добавить( ТекущаяДата());
	МассивПараметров.Добавить( УдалениеНечитаемыхСимволов( Событие));
	МассивПараметров.Добавить( УдалениеНечитаемыхСимволов( ТекстСообщения + ПлюсЗапись));
	МассивПараметров.Добавить( УдалениеНечитаемыхСимволов( ИмяПользователя()));
	МассивПараметров.Добавить( УдалениеНечитаемыхСимволов( ИмяКомпьютера()));
	МассивПараметров.Добавить( УдалениеНечитаемыхСимволов( СтрокаСоединенияИнформационнойБазы()));
	МассивПараметров.Добавить( УдалениеНечитаемыхСимволов( ЗаписатьСообщение( ТекстСообщения+ПлюсЗапись, Событие)));
	МассивПараметров.Добавить( УдалениеНечитаемыхСимволов( ТекстВерсия));
	МассивПараметров.Добавить( УдалениеНечитаемыхСимволов( ТекстНачало));
		
КонецПроцедуры // СообщитьЗаписьЖурнала

// Возвращает структуру параметров запроса, необходимых для получения данных с облака
//
// Возвращаемое значение:
// Структура - параметры запроса.
Функция СформироватьПараметрыЗапроса() Экспорт

	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("УИДМагазина");
	ПараметрыЗапроса.Вставить("УИДКассы");
	ПараметрыЗапроса.Вставить("НачалоПериода");
	ПараметрыЗапроса.Вставить("КонецПериода");
	ПараметрыЗапроса.Вставить("Таймзона");
	ПараметрыЗапроса.Вставить("Касса");
	
	Возврат ПараметрыЗапроса;

КонецФункции // СформироватьПараметрыЗапроса()

// Возвращает структуру для получения ссылки по идентификатору
//
// Параметры:
// ИмяКонфигурации - Строка - имя метаданных конфигурации.
// 
// Возвращаемое значение:
// Структура, где ключ - имя справочника, значение - префикс внутреннего представления ссылки
//
Функция ЗаполнитьЗИСВ( ИмяКонфигурации) Экспорт
	
	ЗИСВ = Новый Структура;
	
	Попытка
		
		// Номенклатура
		Стр = ЗначениеВСтрокуВнутр( Справочники.Номенклатура.ПустаяСсылка());
		ЗИСВ.Вставить( "Номенклатура", Лев( Стр, Найти( Стр, ":")));
		
		// Характеристика
		Если ИмяКонфигурации = "БухгалтерияПредприятия"
			Или ИмяКонфигурации = "Общепит1С" 
			Или ИмяКонфигурации = "БухгалтерияГосударственногоУчреждения"
			Тогда
			
			Стр = ЗначениеВСтрокуВнутр( Справочники.Номенклатура.ПустаяСсылка());
			ЗИСВ.Вставить( "Характеристика", Лев( Стр, Найти( Стр, ":")));
			
		ИначеЕсли ИмяКонфигурации = "УправлениеЖКХ" Тогда
			
			Стр = ЗначениеВСтрокуВнутр( Справочники.КУ_ЛицевыеСчета.ПустаяСсылка());
			ЗИСВ.Вставить( "Номенклатура", Лев( Стр, Найти( Стр, ":")));
			
			Стр = ЗначениеВСтрокуВнутр( Справочники.КУ_ГруппыУслуг.ПустаяСсылка());
			ЗИСВ.Вставить( "Характеристика", Лев( Стр, Найти( Стр, ":")));	
			
		Иначе
			Стр = ЗначениеВСтрокуВнутр( Справочники.ХарактеристикиНоменклатуры.ПустаяСсылка());
			ЗИСВ.Вставить( "Характеристика", Лев( Стр, Найти( Стр, ":")));	
		КонецЕсли;
		
	Исключение
		
		Возврат ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат ЗИСВ;
	
КонецФункции // ЗаполнитьЗИСВ

Функция ПолучитьДатуСтрокой( ДатаДок) Экспорт
	
	Возврат Формат( ДатаДок, "ДФ=гггг-ММ-дд") + " " + Формат( ДатаДок, "ДФ=ЧЧ:мм:сс");
	
КонецФункции // ПолучитьДатуСтрокой

Функция ПолучитьДатуИзСтроки( ДатаСтр) Экспорт
	
	ДатаДокумента = Дата( Сред( ДатаСтр, 9, 2)+"."+Сред( ДатаСтр, 6, 2)+"."+Лев( ДатаСтр, 4)+Сред( ДатаСтр, 11, 9));	
	
	Возврат ДатаДокумента;
	
КонецФункции



////////////////////////////////////////////////////////////////////////////////
// ОТПРАВКА ДАННЫХ НА ОБЛАКО / ПОЛУЧЕНИЕ ДАННЫХ ИЗ ОБЛАКА

// Отправляет данные на облако встроенным http-соединением
//
// Параметры:
// ПараметрыПодключения - структура - ключ: "Токен", значение: ключ доступа для авторизации на Эвотор
// ТипДанных - Строка - что отправляем: "Товары", "ТоварыУдалить", "Сотрудники", "Магазины", "Кассы".
// МассивСтруктуры - массив - массив данных для отправки на облако.
// Uuid - строка - uuid магазина
//
// Возвращаемое значение:
// Истина - отправлено успешно.
// Ложь - возникла ошибка.
//
Функция ОтправитьДанныеМетодом1С( ПараметрыПодключения, ТипДанных, МассивСтруктуры, ЛокальнаяСеть, Uuid="") Экспорт
	
	Заголовки = Новый Соответствие();
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("X-Authorization", ПараметрыПодключения.Токен); 
	//Заголовки.Вставить("Content-Encoding", "gzip");
	Заголовки.Вставить("Version", ПараметрыПодключения.Версия);
	
	Попытка
		
		Если ЛокальнаяСеть Тогда
			Соединение = Новый HTTPСоединение( ПараметрыПодключения.Сервер, 8080);
		Иначе
			Соединение = Новый HTTPСоединение( ПараметрыПодключения.Сервер, 443, , , Новый ИнтернетПрокси( Истина), 300, Новый ЗащищенноеСоединениеOpenSSL);
		КонецЕсли;	
		
	Исключение
		
		Если ИнформацияОбОшибке().Причина <> Неопределено Тогда
			Сообщить( ИнформацияОбОшибке().Причина.Описание);
		КонецЕсли;
		
		Сообщить( "Не удалось установить соединение с сервером.");
		Возврат Ложь;
	КонецПопытки;

	КодировкаANSI = Ложь;
	Если ТипДанных = "Товары" Тогда
		АдресРесурса = "/api/v1/inventories/stores/" + Uuid + "/products";
		Метод = "POST";
	ИначеЕсли ТипДанных = "ТоварыУдалить" Или ТипДанных = "ТоварыУдалитьВсе" Тогда
		АдресРесурса = "/api/v1/inventories/stores/" + Uuid + "/products/delete";
		Метод = "POST";	
	ИначеЕсли ТипДанных = "Сотрудники" Тогда
		АдресРесурса = "/api/v1/inventories/employees/" + Uuid + "/code";
		Метод = "PUT";
	ИначеЕсли ТипДанных = "Магазины" Тогда
		АдресРесурса = "/api/v1/inventories/stores/" + Uuid + "/code";
		Метод = "PUT";
	ИначеЕсли ТипДанных = "Кассы" Тогда
		АдресРесурса = "/api/v1/inventories/devices/" + Uuid + "/code";
		Метод = "PUT";
		
	ИначеЕсли ТипДанных = "Продажи" Тогда
		АдресРесурса = "/api/v1/stores/" + Uuid + "/sales/add";
		Метод = "POST";
		
		// Мультикасса {
	ИначеЕсли ТипДанных = "ТоварыЭкстра" Тогда
		АдресРесурса = "/api/v1/inventories/stores/" + Uuid + "/products/extras";
		Метод = "POST";
		КодировкаANSI = Истина;
	ИначеЕсли ТипДанных = "МультикассаОрганизации" Тогда
		АдресРесурса = "/orgscheme.php";
		Метод = "POST";
		КодировкаANSI = Истина;
		// Мультикасса }
		
	ИначеЕсли ТипДанных = "МобильныйКассир" Тогда
		АдресРесурса = "/api/v1/mobcash";
		Метод = "POST";	
		
	КонецЕсли;
	
	Если КодировкаANSI Тогда
		Заголовки.Вставить("Charset", "windows-1251");
	КонецЕсли;
		
	ИмяФайлаОтвета = ПолучитьИмяВременногоФайла();
	
	HTTPЗапрос = Новый HTTPЗапрос(АдресРесурса, Заголовки);
	
	Если ТипДанных = "ТоварыУдалитьВсе" Тогда
		СтрокаЗапроса = "[]";	
	Иначе
		СтрокаЗапроса = ЗаписатьСтрокуJSON( МассивСтруктуры);
	КонецЕсли;
	МассивСтруктуры = Новый Массив;
	
	
	Если КодировкаANSI Тогда
		HTTPЗапрос.УстановитьТелоИзСтроки( СтрокаЗапроса, КодировкаТекста.ANSI);
	Иначе
		HTTPЗапрос.УстановитьТелоИзСтроки( СтрокаЗапроса);
	КонецЕсли;
	
	Если Метод = "POST" Тогда
		Ответ = Соединение.ОтправитьДляОбработки(HTTPЗапрос, ИмяФайлаОтвета);
	ИначеЕсли Метод = "PUT" Тогда
		Ответ = Соединение.Записать(HTTPЗапрос, ИмяФайлаОтвета);
	ИначеЕсли Метод = "DELETE" Тогда
		Ответ = Соединение.Удалить(HTTPЗапрос);	
	КонецЕсли;
	
	Если Ответ.КодСостояния = 401 Тогда
		Сообщить( "Ключ авторизации неверный.");
		Возврат Ложь;
	ИначеЕсли Ответ.КодСостояния = 402 Тогда
		Сообщить( "Точка продаж, аккаунт или поддержка интеграции заблокирована.");
		Возврат Ложь;
	ИначеЕсли Ответ.КодСостояния = 404 Тогда
		Сообщить( "Не найдена указанная точка продаж.");
		Возврат Ложь;
	ИначеЕсли Ответ.КодСостояния = 500 Тогда
		Сообщить( "Внутренняя ошибка сервиса.");
		Возврат Ложь;
	ИначеЕсли Ответ.КодСостояния = 503 Тогда
		Сообщить( "Сервис недоступен.");
		Возврат Ложь;
	ИначеЕсли НЕ Ответ.КодСостояния = 200 Тогда
		Сообщить( "Не удалось получить подтверждение отправки данных. Код ответа: " + Ответ.КодСостояния);
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // ОтправитьДанные

// Отправляет данные на облако через COM-объект winhttp
//
// Параметры:
// ПараметрыПодключения - структура - ключ: "Токен", значение: ключ доступа для авторизации на Эвотор
// ТипДанных - Строка - что отправляем: "Товары", "ТоварыУдалить", "Сотрудники", "Магазины", "Кассы".
// МассивСтруктуры - массив - массив данных для отправки на облако.
// Uuid - строка - uuid магазина
//
// Возвращаемое значение:
// Истина - отправлено успешно.
// Ложь - возникла ошибка.
//
Функция ОтправитьДанные( Знач ПараметрыПодключения, ТипДанных, МассивДанных, Uuid="", ДругойМетодОбмена=Ложь, Сервер = Неопределено) Экспорт
	
	ЛокальнаяСеть = Ложь;
	Если Сервер = Неопределено ИЛИ Сервер = "" Тогда
		Если ТипДанных = "Продажи" Тогда
			ПараметрыПодключения.Сервер = "http://evoprintsale.akitorg.ru";
		Иначе
			ПараметрыПодключения.Сервер = "https://api.evotor.ru";	
		КонецЕсли;
	Иначе
		Если Не ТипДанных = "МобильныйКассир" Тогда
			ПараметрыПодключения.Сервер = Сервер;
			ЛокальнаяСеть = Истина;
		КонецЕсли;
	КонецЕсли;
		
	Если МассивДанных = Неопределено Тогда
		Возврат Истина;
	ИначеЕсли МассивДанных.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ДругойМетодОбмена Тогда
		
		ПараметрыПодключения.Сервер = СтрЗаменить(ПараметрыПодключения.Сервер, "https://", "");
		ПараметрыПодключения.Сервер = СтрЗаменить(ПараметрыПодключения.Сервер, "http://", "");
		
		Возврат ОтправитьДанныеМетодом1С( ПараметрыПодключения, ТипДанных, МассивДанных, ЛокальнаяСеть, Uuid);
	КонецЕсли;
	
	Заголовки = "Content-Type:application/json" + Символы.ВК + Символы.ПС 
	+ "X-Authorization:" + ПараметрыПодключения.Токен;

	Если ТипДанных = "Товары" Тогда
		АдресРесурса = "/api/v1/inventories/stores/" + Uuid + "/products";
		Метод = "POST";
	ИначеЕсли ТипДанных = "ТоварыУдалить" ИЛИ ТипДанных = "ТоварыУдалитьВсе" Тогда
		АдресРесурса = "/api/v1/inventories/stores/" + Uuid + "/products/delete";
		Метод = "POST";
	ИначеЕсли ТипДанных = "Сотрудники" Тогда
		АдресРесурса = "/api/v1/inventories/employees/" + Uuid + "/code";
		Метод = "PUT";
	ИначеЕсли ТипДанных = "Магазины" Тогда
		АдресРесурса = "/api/v1/inventories/stores/" + Uuid + "/code";
		Метод = "PUT";
	ИначеЕсли ТипДанных = "Кассы" Тогда
		АдресРесурса = "/api/v1/inventories/devices/" + Uuid + "/code";
		Метод = "PUT";
		
	ИначеЕсли ТипДанных = "Продажи" Тогда
		АдресРесурса = "/api/v1/stores/" + Uuid + "/sales/add";
		Метод = "POST";	
		
		// Мультикасса {
	ИначеЕсли ТипДанных = "ТоварыЭкстра" Тогда
		АдресРесурса = "/api/v1/inventories/stores/" + Uuid + "/products/extras";
		Метод = "POST";
		
	ИначеЕсли ТипДанных = "МультикассаОрганизации" Тогда
		АдресРесурса = "/orgscheme.php";
		Метод = "POST";
		// Мультикасса }
		
	ИначеЕсли ТипДанных = "МобильныйКассир" Тогда
		АдресРесурса = "/api/v1/mobcash";
		Метод = "POST";	
		
	КонецЕсли;	
	
	HTTP = Новый COMОбъект("WinHttp.WinHttpRequest.5.1");
	
	Скрипт = Новый COMОбъект("MSScriptControl.ScriptControl");
	Скрипт.language = "javascript";
	Скрипт.AddObject("WinHttp", HTTP);
	Скрипт.Eval("WinHttp.Option(4)=13056");
	
	//HTTP.SetTimeouts(250000, 250000, 250000, 250000);
	
	HTTP.Open( Метод, ПараметрыПодключения.Сервер + АдресРесурса , 0);
	
	HTTP.SetRequestHeader("Content-Type"     , "application/json");
	HTTP.SetRequestHeader("X-Authorization"  , ПараметрыПодключения.Токен);
	HTTP.SetRequestHeader("Version" , ПараметрыПодключения.Версия);
		
	Попытка
		Если ТипДанных = "ТоварыУдалитьВсе" Тогда
			HTTP.Send( "[]");
		Иначе
			HTTP.Send(ЗаписатьСтрокуJSON( МассивДанных));
		КонецЕсли;
	Исключение
		Сообщить(ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	
	МассивДанных = Новый Массив;
	
	HTTP.WaitForResponse();
	
	РезультатЗагрузки = СокрЛП(HTTP.Status());
	
	Если РезультатЗагрузки = "401" Тогда
		Сообщить( "Ключ авторизации неверный. Код ответа:" + РезультатЗагрузки + " " + HTTP.ResponseText);
		Возврат Ложь;
	ИначеЕсли РезультатЗагрузки = "402" Тогда
		Сообщить( "Точка продаж, аккаунт или поддержка интеграции заблокирована. Код ответа:" + РезультатЗагрузки + " " + HTTP.ResponseText);
		Возврат Ложь;
	ИначеЕсли РезультатЗагрузки = "404" Тогда
		Сообщить( "Не найдена указанная точка продаж. Код ответа:" + РезультатЗагрузки + " " + HTTP.ResponseText);
		Возврат Ложь;
	ИначеЕсли РезультатЗагрузки = "500" Тогда
		Сообщить( "Внутренняя ошибка сервиса. Код ответа:" + РезультатЗагрузки + " " + HTTP.ResponseText);
		Возврат Ложь;
	ИначеЕсли РезультатЗагрузки = "503" Тогда
		Сообщить( "Сервис недоступен. Код ответа:" + РезультатЗагрузки + " " + HTTP.ResponseText);
		Возврат Ложь;
	ИначеЕсли НЕ РезультатЗагрузки = "200" Тогда
		Сообщить( "Не удалось получить подтверждение отправки данных. Код ответа: " + РезультатЗагрузки + " " + HTTP.ResponseText);
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // ОтправитьДанные

Функция HEX( Значение)
	
	Результат = "";
	Строка16 = "0123456789ABCDEF";
	
	Пока Значение > 0 Цикл
		Результат = Сред( Строка16, Значение % 16 + 1, 1) + Результат;
		Значение = Цел( Значение / 16);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // HEX

Функция вURL( Стр)
	
	Результат = "";
	
	Для Н = 1 По СтрДлина( Стр) Цикл
		
		КодСимволаН = КодСимвола( Стр, Н);
		
		Если КодСимволаН < 128 Тогда
			
			Результат = Результат + "%" + HEX( КодСимволаН);
			
		ИначеЕсли КодСимволаН < 2048 Тогда
			
            Байт2 = КодСимволаН % 64;
            Байт1 = Цел((КодСимволаН - Байт2) / 64);
            Результат = Результат + "%" + HEX(192 + Байт1) + "%" + HEX(128 + Байт2);
			
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // вURL

// Возвращает текст ошибки по коду ответа с сервера Эвотор
// 
// Параметры:
// Код - число - код ответа с сервера.
//
// Возвращаемое значение:
// Строка - текст ошибки.
//
Функция ТекстОшибкиПоКоду( Код)
	
	СоответствиеОшибки = Новый Соответствие;
	
	СоответствиеОшибки.Вставить( 200, "");
	СоответствиеОшибки.Вставить( 400, "Ошибка в запросе. ");
	СоответствиеОшибки.Вставить( 401, "Неудачная авторизация.");
	СоответствиеОшибки.Вставить( 402, "Подписка для данного пользователя не активна. Требуется оплата. ");
	СоответствиеОшибки.Вставить( 404, "Страница не существует. ");
	СоответствиеОшибки.Вставить( 405, "Данный терминал не активен в рамках текущей подписки. Активируйте терминал и повторите. ");
	СоответствиеОшибки.Вставить( 409, "Регистрационные данные совпадают с уже существующей учетной записью в системе партнера. Регистрация невозможна. ");
	СоответствиеОшибки.Вставить( 500, "Внутренняя ошибка сервиса. ");
	СоответствиеОшибки.Вставить( 503, "Сервис недоступен. ");
	
	ТекстОшибки = СоответствиеОшибки[ Число(Код)];
	Если ТекстОшибки = Неопределено Тогда
		ТекстОшибки = "";
	КонецЕсли;
	
	Возврат ТекстОшибки;
	
КонецФункции

// Получает данные из облака встроенным http-соединением
//
// Параметры:
// ПараметрыПодключения - структура - ключ: "Токен", значение: ключ доступа для авторизации на Эвотор
// ТипДанных - Строка - что отправляем: "Товары", "Документы", "Сотрудники", "Магазины", "Кассы".
// Результат - массив - в эту переменную будет записан результат загрузки.
// ПараметрыЗапроса - строка, структура - параметры запроса: 
//				для товаров - УИДМагазина; 
//				для документов - УИДМагазина, УИДКассы, НачалоПериода, КонецПериода;
//				для сотрудников, магазинов и касс - пустая строка.
//
// Возвращаемое значение:
// Истина - отправлено успешно.
// Ложь - возникла ошибка.
//
Функция ПолучитьДанныеМетодом1С( Сервер, Заголовки, АдресРесурса, Результат, ЛокальнаяСеть, ПараметрыЗапроса="") Экспорт
		
	ТекстОтвета = Неопределено;
	
	Попытка
		
		Если Сервер = "api.evotor.ru" Тогда	
			Соединение = Новый HTTPСоединение( Сервер, 443, , , Новый ИнтернетПрокси( Истина), 360, Новый ЗащищенноеСоединениеOpenSSL);
		ИначеЕсли ЛокальнаяСеть Тогда
			Соединение = Новый HTTPСоединение( Сервер, 8080, , , Новый ИнтернетПрокси( Истина), 300);
		Иначе
			Соединение = Новый HTTPСоединение( СтрЗаменить(Сервер,"http://", ""), 80, , , Новый ИнтернетПрокси( Истина), 360, );
		КонецЕсли;
		
	Исключение
		
		Сообщить( ИнформацияОбОшибке().Причина.Описание);
		ВызватьИсключение "Не удалось установить соединение с сервером.";
		
		Возврат Ложь;
		
	КонецПопытки;
	
	ИмяФайлаОтвета = ПолучитьИмяВременногоФайла();
	
	Попытка
		
		ЗапросHTTP = Новый HTTPЗапрос(АдресРесурса, Заголовки);
		
		Если ЗначениеЗаполнено( ПараметрыЗапроса) Тогда
			ЗапросHTTP.УстановитьТелоИзСтроки( ПараметрыЗапроса);
			Ответ = Соединение.ОтправитьДляОбработки( ЗапросHTTP, ИмяФайлаОтвета);
		Иначе
			Ответ = Соединение.Получить( ЗапросHTTP, ИмяФайлаОтвета);
		КонецЕсли;	
		
	Исключение
		
		Сообщить( ОписаниеОшибки());
		ВызватьИсключение "Не удалось получить данные.";
		
		Возврат Ложь;
		
	КонецПопытки;
	
	Если НЕ Ответ.КодСостояния = 200 Тогда
		ТекстОшибки = ТекстОшибкиПоКоду( Ответ.КодСостояния);
		Если ПустаяСтрока( ТекстОшибки) Тогда
			ТекстОшибки = "Не удалось получить данные. Код ответа: " + Ответ.КодСостояния;
		КонецЕсли;
		
		Если Ответ.КодСостояния = 405 Тогда
			Результат = Новый Массив;
			Сообщить( "" + ПараметрыЗапроса.Касса + ": " + ТекстОшибки);
			Возврат Истина;
		КонецЕсли;
		
		Сообщить( ТекстОшибки);
		Возврат Ложь;
	КонецЕсли;
	
	ТекстОтвета = Новый ЧтениеТекста;
	ТекстОтвета.Открыть( ИмяФайлаОтвета, КодировкаТекста.UTF8);
	
	Стр = ТекстОтвета.Прочитать();
	
	Если Стр = Неопределено Тогда
		Стр = "";
	КонецЕсли;
	
	Стр = СтрЗаменить( Стр, "'", "");
	Стр = СтрЗаменить( Стр, "\u0000", "");
	
	Результат = Новый Массив;
	
	Если ПустаяСтрока( Стр) ИЛИ Стр = "[]" Тогда
		Возврат Истина;
	КонецЕсли;
	
	Ошибки = "";
	Если НЕ jsonParse( Стр, Результат, Ошибки) Тогда
		
		Попытка
			Результат = ПрочитатьСтрокуJSON( Стр);//ЗаполнитьСтруктуруИзОтветаJSON( Стр);
		Исключение
			Сообщить( Ошибки);
			Возврат Ложь;
		КонецПопытки;
		
	КонецЕсли;

	Возврат Истина;
	
КонецФункции // ПолучитьДанные

// Получает данные из облака через COM-объект winhttp
//
// Параметры:
// ПараметрыПодключения - структура - ключ: "Токен", значение: ключ доступа для авторизации на Эвотор
// ТипДанных - Строка - что отправляем: "Товары", "Документы", "Сотрудники", "Магазины", "Кассы".
// Результат - массив - в эту переменную будет записан результат загрузки.
// ПараметрыЗапроса - строка, структура - параметры запроса: 
//				для товаров - УИДМагазина; 
//				для документов - УИДМагазина, УИДКассы, НачалоПериода, КонецПериода;
//				для сотрудников, магазинов и касс - пустая строка.
//
// Возвращаемое значение:
// Истина - отправлено успешно.
// Ложь - возникла ошибка.
//
Функция ПолучитьДанные( ПараметрыПодключения, ТипДанных, Результат, ПараметрыЗапроса="", ДругойМетодОбмена=Ложь, Сервер = Неопределено, NEXT_CURSOR = "", ОбработатьV2 = Истина) Экспорт
	
	ЛокальнаяСеть = Ложь;
	
	Если Сервер = Неопределено ИЛИ Сервер = "" Тогда
		Если ТипДанных = "Оплаты" Тогда
			ПараметрыПодключения.Сервер = "http://evoprintsale.akitorg.ru";	
		КонецЕсли;
	Иначе
		Если Не ТипДанных = "МобильныйКассир" Тогда 
			ПараметрыПодключения.Сервер = Сервер;
			ЛокальнаяСеть = Истина;                    
		КонецЕсли;
	КонецЕсли;
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить( "Content-Type"		, "application/json");
	Заголовки.Вставить( "X-Authorization"	, ПараметрыПодключения.Токен);
	Заголовки.Вставить( "Version"			, ПараметрыПодключения.Версия);
	
	ТелоЗапроса = "";
	Если ТипДанных = "Товары" Тогда
		АдресРесурса = "api/v1/inventories/stores/<УИДМагазина>/products";	
		АдресРесурса = СтрЗаменить(АдресРесурса, "<УИДМагазина>", ПараметрыЗапроса.УИДмагазина);
		
	ИначеЕсли ТипДанных = "Документы" Тогда
		
		////ПараметрыПодключения.Сервер = "dev.akitorg.ru";
		////
		////АдресРесурса = "api/v1/inventories/stores/<УИДМагазина>/documents?gtCloseDate=<НачалоПериода>&ltCloseDate=<КонецПериода>&deviceUuid=<УИДКассы>";
		////АдресРесурса = СтрЗаменить(АдресРесурса, "<УИДМагазина>", ПараметрыЗапроса.УИДМагазина);
		////
		////Если ПараметрыЗапроса.УИДКассы = Неопределено Тогда
		////	АдресРесурса = СтрЗаменить(АдресРесурса, "&deviceUuid=<УИДКассы>", "");	
		////Иначе
		////	АдресРесурса = СтрЗаменить(АдресРесурса, "<УИДКассы>", ПараметрыЗапроса.УИДКассы);
		////КонецЕсли;
		////
		////АдресРесурса = СтрЗаменить(АдресРесурса, "<НачалоПериода>", ЗаписатьДатуВJSON( ПараметрыЗапроса.НачалоПериода, ПараметрыЗапроса.Таймзона)); //"2016-09-14T00:00:00.000%2B0000"
		////АдресРесурса = СтрЗаменить(АдресРесурса, "<КонецПериода>",  ЗаписатьДатуВJSON( ПараметрыЗапроса.КонецПериода, ПараметрыЗапроса.Таймзона));	
		
		//api2	
		ПараметрыПодключения.Сервер = "api.evotor.ru";
		
		АдресРесурса = "stores/<УИДМагазина>/documents?since=<НачалоПериода>&until=<КонецПериода>";
		АдресРесурса = СтрЗаменить(АдресРесурса, "<УИДМагазина>", 	ПараметрыЗапроса.УИДМагазина);
		
		unixDateFrom = (ПараметрыЗапроса.НачалоПериода - Дата(1970, 1, 1)) * 1000;
		АдресРесурса = СтрЗаменить(АдресРесурса, "<НачалоПериода>", Формат(unixDateFrom, "ЧРД=.; ЧН=0; ЧГ=0")); 
		unixDateTo	 = (ПараметрыЗапроса.КонецПериода - Дата(1970, 1, 1)) * 1000;
		АдресРесурса = СтрЗаменить(АдресРесурса, "<КонецПериода>",  Формат(unixDateTo, "ЧРД=.; ЧН=0; ЧГ=0"));
		
	ИначеЕсли ТипДанных = "Оплаты" Тогда
		
		АдресРесурса = "api/v1/stores/<УИДМагазина>/payments";
		АдресРесурса = СтрЗаменить(АдресРесурса, "<УИДМагазина>"	, ПараметрыЗапроса.УИДМагазина);
		
		МассивПараметров = Новый Массив;
		
		СтруктураПараметровПериод = Новый Структура;
		СтруктураПараметровПериод.Вставить( "date_from"	, ПолучитьДатуСтрокой( ПараметрыЗапроса.НачалоПериода));
		СтруктураПараметровПериод.Вставить( "date_to"	, ПолучитьДатуСтрокой( ПараметрыЗапроса.КонецПериода));
		
		МассивПараметров.Добавить( СтруктураПараметровПериод);
		
		ТелоЗапроса = ЗаписатьСтрокуJSON( МассивПараметров);
		
	ИначеЕсли ТипДанных = "Сотрудники" Тогда
		АдресРесурса = "api/v1/inventories/employees/search";
		
	ИначеЕсли ТипДанных = "Магазины" Тогда
		АдресРесурса = "api/v1/inventories/stores/search";
		
	ИначеЕсли ТипДанных = "Кассы" Тогда
		АдресРесурса = "api/v1/inventories/devices/search";
		
	Иначе
		Возврат Истина;
	КонецЕсли;
	
	Успех = Ложь;
	ТекстОтвета = "";
	
	Успех = ПолучитьДанныеМетодом1С( ПараметрыПодключения.Сервер, Заголовки, АдресРесурса, Результат, ЛокальнаяСеть, ТелоЗапроса);
	
	Если Не Успех Тогда
		Возврат Ложь;                    
	КонецЕсли;
	
	Ответ_ = Результат;
	Попытка
		Если Результат[0].Свойство("items") Тогда
			
			Результат = Результат[0].items;
			
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	Попытка
		Если Ответ_[0].Свойство("paging") Тогда
			
			СледующаяСтраница = Ответ_[0].paging;
			
			Если СледующаяСтраница.Свойство("next_cursor") Тогда
				
				NEXT_CURSOR = СледующаяСтраница.next_cursor;
				
				СледующийРезультат = Неопределено;
				ПолучитьДанные(ПараметрыПодключения, ТипДанных, СледующийРезультат, ПараметрыЗапроса, ДругойМетодОбмена, "api.evotor.ru", NEXT_CURSOR, ОбработатьV2);
				Если Не СледующийРезультат = Неопределено Тогда
					
					Для Каждого Элемент ИЗ СледующийРезультат Цикл
						Результат.Добавить(Элемент);
					КонецЦикла;	  	
					
				КонецЕсли;	
				
			КонецЕсли;
			
		КонецЕсли; 
	Исключение
	КонецПопытки;
	
	Возврат Истина;
	
	////Если ДругойМетодОбмена Тогда
	////	
	////	Если ТипДанных = "Документы" Тогда
	////		АдресРесурса = "evotor/" + АдресРесурса;
	////	КонецЕсли;	
	////	
	////	Возврат ПолучитьДанныеМетодом1С( ПараметрыПодключения.Сервер, Заголовки, АдресРесурса, Результат, ЛокальнаяСеть, ТелоЗапроса);
	////КонецЕсли;
	////
	////Попытка
	////	
	////	HTTP = Новый COMОбъект("WinHttp.WinHttpRequest.5.1");
	////	
	////	Скрипт = Новый COMОбъект("MSScriptControl.ScriptControl");
	////	Скрипт.language = "javascript";
	////	Скрипт.AddObject("WinHttp", HTTP);
	////	Скрипт.Eval("WinHttp.Option(4)=13056");
	////	
	////	//HTTP.SetTimeouts(250000, 250000, 250000, 250000);
	////	
	////	Если НЕ ТипДанных = "Оплаты" Тогда
	////		HTTP.Open( "GET", "http://dev.akitorg.ru/evotor/" + АдресРесурса , 0);
	////	Иначе
	////		HTTP.Open( "GET", ПараметрыПодключения.Сервер + "/" + АдресРесурса , 0);
	////	КонецЕсли;
	////	
	////	Для Каждого Пара Из Заголовки Цикл
	////		HTTP.SetRequestHeader( Пара.Ключ, Пара.Значение);	
	////	КонецЦикла;
	////	
	////Исключение
	////	ДругойМетодОбмена = Истина;
	////	Возврат ПолучитьДанныеМетодом1С( ПараметрыПодключения.Сервер, Заголовки, АдресРесурса, Результат, ЛокальнаяСеть, ТелоЗапроса);
	////КонецПопытки;

	////Попытка
	////	HTTP.Send( ТелоЗапроса);
	////Исключение
	////	Сообщить(ОписаниеОшибки());
	////	Возврат Ложь;
	////КонецПопытки;
	////
	////HTTP.WaitForResponse();
	////
	////КодСостояния = HTTP.Status();
	////
	////Если НЕ КодСостояния = 200 Тогда
	////	ТекстОшибки = ТекстОшибкиПоКоду( КодСостояния);
	////	Если ПустаяСтрока( ТекстОшибки) Тогда
	////		ТекстОшибки = "Не удалось получить данные. Код ответа: " + КодСостояния + ". " + HTTP.ResponseText;
	////	КонецЕсли;
	////	
	////	Если КодСостояния = 405 Тогда
	////		Результат = Новый Массив;
	////		Сообщить( "" + ПараметрыЗапроса.Касса + ": " + ТекстОшибки);
	////		Возврат Истина;
	////	КонецЕсли;
	////	
	////	Сообщить( ТекстОшибки + Символы.ПС + HTTP.ResponseText);
	////	Возврат Ложь;
	////КонецЕсли;
	////
	////ТекстОтвета = HTTP.ResponseText;
	////
	////Результат = Новый Массив;
	////Если ПустаяСтрока( ТекстОтвета) ИЛИ ТекстОтвета = "[]" Тогда
	////	Возврат Истина;
	////КонецЕсли;
	////
	////Ошибки = "";
	////Если НЕ jsonParse( ТекстОтвета, Результат, Ошибки) Тогда
	////	
	////	Попытка
	////		Результат = ПрочитатьСтрокуJSON( ТекстОтвета);//ЗаполнитьСтруктуруИзОтветаJSON( Стр);
	////	Исключение
	////		Сообщить( Ошибки);
	////		Возврат Ложь;
	////	КонецПопытки;
	////	
	////КонецЕсли;
    ////
	////Возврат Истина;
	
КонецФункции // ПолучитьДанные


#Область JSONПарсер 

Процедура ЗаполнитьДанныеИзОтветаJSON(Результат, ТекстJSON, ТипДанных)

	ТекстJSON = СокрЛП(Сред(ТекстJSON, 2)); // удалим открывающий символ структуры(массива)
	НомерЗначения = 0;
	
	Пока ТекстJSON <> "" Цикл
		
		ПервыйСимвол = Лев(ТекстJSON, 1);
		
		Если ПервыйСимвол = "{" Тогда //вложенная структура
			
			Значение = Новый Структура;
			ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Структура");
			
			Если ТипДанных = "Структура" Тогда
				
				Результат.Вставить("Значение" + ?(НомерЗначения = 0, "", НомерЗначения), Значение);
				НомерЗначения = НомерЗначения + 1;
				
			ИначеЕсли ТипДанных = "Массив" Тогда
				
				Результат.Добавить(Значение);
				
			КонецЕсли;
			
		ИначеЕсли ПервыйСимвол = "[" Тогда //вложенный массив
			
			Значение = Новый Массив;
			ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Массив");
			
			Если ТипДанных = "Структура" Тогда
				
				Результат.Вставить("Значение" + ?(НомерЗначения = 0, "", НомерЗначения), Значение);
				НомерЗначения = НомерЗначения + 1;
				
			Иначе
				
				Результат.Добавить(Значение);
				
			КонецЕсли;
			
		ИначеЕсли ПервыйСимвол = "}" И ТипДанных = "Структура" Тогда //структура закончилась
			
			ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			
			Если Лев(ТекстJSON, 1) = "," Тогда
				
				ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
				
			КонецЕсли;
			
			Возврат;
			
		ИначеЕсли ПервыйСимвол = "]" И ТипДанных = "Массив" Тогда //массив закончился
			
			ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			
			Если Лев(ТекстJSON, 1) = "," Тогда
				
				ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
				
			КонецЕсли;
			
			Возврат;
			
		Иначе
			
			Если ТипДанных = "Структура" Тогда
				
				Поз = Найти(ТекстJSON, ":");
				
				Если Поз = 0 Тогда
					
					Прервать;
					
				КонецЕсли;
				
				ИмяЗначения = СокрЛП(Лев(ТекстJSON, Поз - 1));
				ИмяЗначения = СтрЗаменить(ИмяЗначения, """", "");
				
				ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз+1));
				
				Если Лев(ТекстJSON, 1) = "{" Тогда //значение является структурой
					
					Значение = Новый Структура;
					ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Структура");
					
				ИначеЕсли Лев(ТекстJSON, 1) = "[" Тогда //значение является массивом
					
					Значение = Новый Массив;
					ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Массив");
					
				Иначе // обычное значение
					
					ПервыйКавычка = Ложь;
					ПредпоследнийКавычка = Ложь;
					Поз = 0;
					Для Сч = 1 По СтрДлина(ТекстJSON) Цикл
						Символ = Сред(ТекстJSON, Сч, 1);
						
						Если Символ = """" Тогда
							
							Если ПервыйКавычка Тогда
								
								ПредпоследнийКавычка = Истина;
								
							Иначе
								ПервыйКавычка = Истина;
								
							КонецЕсли;
							
						КонецЕсли;
						
						Если (Символ = "," И ((ПервыйКавычка И ПредпоследнийКавычка) Или (Не ПервыйКавычка И Не ПредпоследнийКавычка))) ИЛИ Символ = "]" ИЛИ Символ = "}" Тогда
							
							Поз = Сч;
							
							Прервать;
							
						КонецЕсли;
						
					КонецЦикла;
					
					Если Поз = 0 Тогда
						
						Значение = ТекстJSON;
						ТекстJSON = "";
						
					Иначе
						
						Значение = Лев(ТекстJSON, Поз - 1);
						Значение = СтрЗаменить(Значение, """", "");
						ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз + ?(Сред(ТекстJSON, Поз, 1) = ",", 1, 0)));
						
					КонецЕсли;
					
					Значение = СокрЛП(Значение);
					
				КонецЕсли;
				
				Попытка
					Результат.Вставить(ИмяЗначения, Значение);
				Исключение
					//Сообщить( "" + ИмяЗначения + " - " + Значение);
				КонецПопытки;
				
				
			ИначеЕсли ТипДанных = "Массив" Тогда //обычное значение
				
				Поз = 0;
				
				Для Сч = 1 По СтрДлина(ТекстJSON) Цикл
					
					Символ = Сред(ТекстJSON, Сч, 1);
					
					Если Символ = "," ИЛИ Символ = "]" ИЛИ Символ = "}" Тогда
						
						Поз = Сч;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
				Если Поз = 0 Тогда
					
					Значение = ТекстJSON;
					ТекстJSON = "";
					
				Иначе
					
					Значение = Лев(ТекстJSON, Поз - 1);
					Значение = СтрЗаменить(Значение, """", "");
					ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз + ?(Сред(ТекстJSON, Поз, 1) = ",", 1, 0)));
					
				КонецЕсли;
				
				Значение = СокрЛП(Значение);
				
				Результат.Добавить(Значение);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры
//______________________________________________________________________________
Функция ПреобразоватьвСистему(Число10,система) Экспорт
	Если система > 36 или система < 2 тогда
		Сообщить("Выбранная система исчисления не поддерживается");
		Возврат -1;
	КонецЕсли;
	
	СтрокаЗначений = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	СтрокаСистема = "";
	Пока Число10 > 0 цикл
		РезДеления = Число10/система;
		ЧислоСистема = цел(РезДеления);
		остатокОтДеления = Число10 - система*(ЧислоСистема);
		СтрокаСистема = сред(СтрокаЗначений,остатокОтДеления+1,1)+ СтрокаСистема;
		Число10 = ?(ЧислоСистема=0,0,РезДеления); 
	КонецЦикла;
	
	Нечётное = стрДлина(СтрокаСистема) - цел(стрДлина(СтрокаСистема)/2)*2;
	Если Нечётное тогда
		СтрокаСистема = "0"+СтрокаСистема;
	КонецЕсли;
	
	Возврат СтрокаСистема;
КонецФункции
//______________________________________________________________________________
Функция URLEncode(стр) Экспорт	
	Длина=СтрДлина(Стр);
	Итог="";
	Для Н=1 По Длина Цикл
		Знак=Сред(Стр,Н,1);
		Код=КодСимвола(Знак);
		
		если ((Знак>="a")и(Знак<="z")) или
			 ((Знак>="A")и(Знак<="Z")) или
			 ((Знак>="0")и(Знак<="9")) тогда
			Итог=Итог+Знак;
		Иначе
			Если (Код>=КодСимвола("А"))И(Код<=КодСимвола("п")) Тогда
				Итог=Итог+"%"+ПреобразоватьвСистему(208,16)+"%"+ПреобразоватьвСистему(144+Код-КодСимвола("А"),16);
			ИначеЕсли (Код>=КодСимвола("р"))И(Код<=КодСимвола("я")) Тогда
				Итог=Итог+"%"+ПреобразоватьвСистему(209,16)+"%"+ПреобразоватьвСистему(128+Код-КодСимвола("р"),16);
			ИначеЕсли (Знак="ё") Тогда
				Итог=Итог+"%"+ПреобразоватьвСистему(209,16)+"%"+ПреобразоватьвСистему(145,16);
			ИначеЕсли (Знак="Ё") Тогда
				Итог=Итог+"%"+ПреобразоватьвСистему(208,16)+"%"+ПреобразоватьвСистему(129,16);
			Иначе
				Итог=Итог+"%"+ПреобразоватьвСистему(Код,16);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Итог;
КонецФункции
//______________________________________________________________________________
Функция СформироватьСтрокуJSONИзМассива(Объект)
	СтрокаJSON = "[";
	
	Для каждого Элемент Из Объект Цикл
		Если ТипЗнч(Элемент) = Тип("Строка") Тогда
			СтрокаJSON = СтрокаJSON + """" + Элемент + """";
		ИначеЕсли ТипЗнч(Элемент) = Тип("Число") Тогда
			СтрокаJSON = СтрокаJSON + СтрЗаменить(Строка(Элемент), Символы.НПП, "");
		ИначеЕсли ТипЗнч(Элемент) = Тип("Булево") Тогда
			СтрокаJSON = СтрокаJSON + Формат(Элемент, "БЛ=false; БИ=true");
		ИначеЕсли ТипЗнч(Элемент) = Тип("Дата") Тогда
			СтрокаJSON = СтрокаJSON + Формат(Элемент - Дата(1970,1,1,1,0,0), "ЧГ=0");
		ИначеЕсли ТипЗнч(Элемент) = Тип("Массив") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент);
		ИначеЕсли ТипЗнч(Элемент) = Тип("Структура") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент);
		ИначеЕсли ТипЗнч(Элемент) = Тип("ТаблицаЗначений") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент);
		Иначе
			СтрокаJSON = СтрокаJSON + """" + URLEncode(Строка(Элемент)) + """";
		КонецЕсли;
		
		СтрокаJSON = СтрокаJSON + ",";
	КонецЦикла;
	
	Если Прав(СтрокаJSON, 1) = "," Тогда
		СтрокаJSON = Лев(СтрокаJSON, СтрДлина(СтрокаJSON)-1);
	КонецЕсли;
	
	Возврат СтрокаJSON + "]";
КонецФункции
//______________________________________________________________________________
Функция СформироватьСтрокуJSONИзСтруктуры(Объект)
	СтрокаJSON = "{";
	
	Для каждого Элемент Из Объект Цикл
		Если Элемент.Значение = "" Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаJSON = СтрокаJSON + """" + Элемент.Ключ + """" + ":";
		
		Если ТипЗнч(Элемент.Значение) = Тип("Строка") Тогда
			СтрокаJSON = СтрокаJSON + """" + Элемент.Значение + """";
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Число") Тогда
			СтрокаJSON = СтрокаJSON + СтрЗаменить(Строка(Элемент.Значение), Символы.НПП, "");
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Булево") Тогда
			СтрокаJSON = СтрокаJSON + Формат(Элемент.Значение, "БЛ=false; БИ=true");
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Дата") Тогда
			СтрокаJSON = СтрокаJSON + Формат(Элемент.Значение - Дата(1970,1,1,1,0,0), "ЧГ=0");
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Массив") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент.Значение);
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Структура") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент.Значение);
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("ТаблицаЗначений") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент.Значение);
		Иначе
			СтрокаJSON = СтрокаJSON + """" + URLEncode(Строка(Элемент.Значение)) + """";
		КонецЕсли;
		
		СтрокаJSON = СтрокаJSON + ",";
	КонецЦикла;
	
	Если Прав(СтрокаJSON, 1) = "," Тогда
		СтрокаJSON = Лев(СтрокаJSON, СтрДлина(СтрокаJSON)-1);
	КонецЕсли;
	
	Возврат СтрокаJSON + "}";
КонецФункции
//______________________________________________________________________________
Функция ЗаполнитьСтруктуруИзОтветаJSON(ТекстJSON)

	Результат = Новый Структура;
	ТекстJSON = СтрЗаменить(ТекстJSON, "\""", """"); // заменим последовательность \" на "
	ТекстJSON = СтрЗаменить(ТекстJSON, """", ""); // а теперь удалим все кавычки
	
	Если Лев(ТекстJSON, 1) = "{" Тогда  // начало структуры
		
		ЗаполнитьДанныеИзОтветаJSON(Результат, ТекстJSON, "Структура");
		
	ИначеЕсли Лев(ТекстJSON, 1) = "[" Тогда //начало массива
		
		МассивДанных = Новый Массив;
		ЗаполнитьДанныеИзОтветаJSON(МассивДанных, ТекстJSON, "Массив");
		Результат.Вставить("Значение", МассивДанных);
		
	КонецЕсли;
	
	Возврат Результат;

КонецФункции
//______________________________________________________________________________
Функция СформироватьСтрокуJSON(Объект) Экспорт
	СтрокаJSON = "";
	
	Если ТипЗнч(Объект) = Тип("Массив") Тогда
		СтрокаJSON = СформироватьСтрокуJSONИзМассива(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("Структура") Тогда
		СтрокаJSON = СформироватьСтрокуJSONИзСтруктуры(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ТаблицаЗначений") Тогда
		СоставСтруктуры = "";
		Для каждого Колонка Из Объект.Колонки Цикл
			СоставСтруктуры = СоставСтруктуры + ?(ЗначениеЗаполнено(СоставСтруктуры), ",", "") + Колонка.Имя;
		КонецЦикла;
		
		МассивСтрок = Новый Массив;
		Для каждого Строка Из Объект Цикл
			СтруктураКолонок = Новый Структура(СоставСтруктуры);
			ЗаполнитьЗначенияСвойств(СтруктураКолонок, Строка);
			МассивСтрок.Добавить(СтруктураКолонок);
		КонецЦикла;
		
		СтрокаJSON = СформироватьСтрокуJSONИзМассива(МассивСтрок);
	КонецЕсли;
	
	Возврат СтрокаJSON;
КонецФункции
//______________________________________________________________________________ 
Функция ПреобразоватьЧасовойПояс(Смещение = Неопределено)
	
	Если Смещение = Неопределено Тогда
		Смещение = СмещениеСтандартногоВремени(ЧасовойПоясСеанса(),УниверсальноеВремя(ТекущаяДатаСеанса()))/60/60;
	КонецЕсли;
	
	Если Смещение < 0 Тогда
		Знак = "%2D";
		Смещение = Смещение * (-1);
	Иначе
		Знак = "%2B";
	КонецЕсли;
	
	КолвоЧасов = ?(Смещение > 9, Строка(Смещение), "0" + Строка(Смещение));
	
	Возврат ".000" + Знак + КолвоЧасов + "00";
	
КонецФункции
//______________________________________________________________________________
Функция ЗаписатьДатуВJSON( ВыбДата, Таймзона=Неопределено) Экспорт
	
	Возврат Формат( ВыбДата, "ДФ=гггг-ММ-дд") + "T" + Формат( ВыбДата, "ДФ=ЧЧ:мм:сс") + ПреобразоватьЧасовойПояс( Таймзона); //".000%2B0000";
	//Возврат Формат( ВыбДата, "ДФ=гггг-ММ-дд") + "T" + Формат( ВыбДата, "ДЛФ=В") + ПреобразоватьЧасовойПояс( Таймзона); //".000%2B0000";		
	//Возврат Формат( ВыбДата, "ДФ=гггг-ММ-дд") + "T" + Формат( ВыбДата, "ДЛФ=В") + ".000%2B0000"; //ПреобразоватьЧасовойПояс(); 	
	
КонецФункции
//______________________________________________________________________________


// 1C:JSON Parser AkiTorg 15/02/2017
Функция ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали)
	
	Если Прочитали < ДлинаТекста Тогда
		Стр = Сред( textJSON, Прочитали + 1, 500);
		Прочитали = Прочитали + 500;
	Иначе
		Стр = Неопределено;
	КонецЕсли;
	
	Возврат Стр;
	
КонецФункции // ЧтениеТекстаПрочитать
//______________________________________________________________________________
Функция jsonParse( textJSON, НовыйМассив, Ошибки)
	
	Если ПустаяСтрока( textJSON) Тогда
		Ошибки = "Текст пустой!";
		Возврат Ложь;
	КонецЕсли;
	
	ДлинаТекста = СтрДлина( textJSON);
	Прочитали = 0;
	Смещение = 1;
	НетОшибок = Истина;
	
	// Убираем пробелы в начале
	Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
	Пока ПустаяСтрока( Стр) Цикл
		
		Смещение = Смещение + СтрДлина( Стр);
		Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
		
		Если Стр = Неопределено Тогда
			Ошибки = "Текст пустой!";
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
		
	ДлинаСтр = СтрДлина( Стр);
	Стр = СокрЛ( Стр);
	Смещение = Смещение + (ДлинаСтр - СтрДлина( Стр));
	
	ПервыйСимвол = Лев( Стр, 1);
	Если ПервыйСимвол = "[" Тогда // Массив
		
		Стр = Сред( Стр, 2);
		Смещение = Смещение + 1;
				
		НетОшибок = jsonArray( НовыйМассив, Стр, textJSON, Смещение, ДлинаТекста, Прочитали, Ошибки);
		
	ИначеЕсли ПервыйСимвол = "{" Тогда // Структура
		
		Стр = Сред( Стр, 2);
		Смещение = Смещение + 1;
			
		НоваяСтруктура = Новый Структура;
		НетОшибок = jsonStruct( НоваяСтруктура, Стр, textJSON, Смещение, ДлинаТекста, Прочитали, Ошибки);
		НовыйМассив.Добавить( НоваяСтруктура);
				
	Иначе
		Ошибки = "("+Смещение+") Данные должны начинаться с открывающей скобки квадратной или фигурной!";
		НетОшибок = Ложь;
	КонецЕсли;
		
	Возврат НетОшибок;
	
КонецФункции // jsonParse
//______________________________________________________________________________
Функция jsonStringToDate( Стр)
	
	Если СтрДлина( Стр) < 24
	ИЛИ Сред( Стр, 5, 1) <> "-"
	ИЛИ Сред( Стр, 8, 1) <> "-"
	ИЛИ Сред( Стр, 11, 1) <> "T"
	ИЛИ Сред( Стр, 14, 1) <> ":"
	ИЛИ Сред( Стр, 17, 1) <> ":"
	ИЛИ Сред( Стр, 20, 1) <> "."
	ИЛИ Сред( Стр, 24, 1) <> "Z"
	Тогда
	
		Возврат Стр;
	КонецЕсли;
	
	ЗначениеДата = Лев( Стр, 4) + Сред( Стр, 6, 2) + Сред( Стр, 9, 2) + Сред( Стр, 12, 2) + Сред( Стр, 15, 2) + Сред( Стр, 18, 2); 
	Попытка
		ЗначениеДата = Число( ЗначениеДата);
	Исключение
		Возврат Стр;
	КонецПопытки;
	
	Попытка
		ЗначениеДата = Дата( ЗначениеДата);
	Исключение
		ЗначениеДата = Стр;
	КонецПопытки;
	
	Возврат ЗначениеДата;
	
КонецФункции // jsonStringToDate
//______________________________________________________________________________
Функция jsonFromHEX( Стр)
	
	Если СтрДлина( Стр) <> 4 Тогда
		Возврат Стр;
	КонецЕсли;
	Стр = Нрег( Стр);
	
	КодСимвола = 0;
	Множитель = 16*16*16;
	
	Для НПП = 1 по 4 Цикл
		
		Цифра = Найти( "0123456789abcdef", Сред( Стр, НПП, 1)) - 1;
		Если Цифра < 0 Тогда
			Возврат Стр;
		КонецЕсли;
		
		КодСимвола = КодСимвола + Множитель * Цифра;
		Множитель = Множитель / 16;
	КонецЦикла;
	
	Возврат Символ( КодСимвола);
	
КонецФункции // jsonFromHEX
//______________________________________________________________________________
Функция jsonUnmask( Стр)
	
	Если Найти( Стр, "\") = 0 Тогда
		Возврат jsonStringToDate( Стр);	
	КонецЕсли;
	
	Стр = СтрЗаменить( Стр, "\\", "\");
	Стр = СтрЗаменить( Стр, "\/", "/");
	Стр = СтрЗаменить( Стр, "\""", """");
	Стр = СтрЗаменить( Стр, "\b", " ");
	Стр = СтрЗаменить( Стр, "\n", Символы.ПС);
	Стр = СтрЗаменить( Стр, "\r", Символы.ВК);
	Стр = СтрЗаменить( Стр, "\t", Символы.Таб);
	Стр = СтрЗаменить( Стр, "\f", Символ(12));
	
	ПозицияЮникод = Найти( Стр, "\u");
	Пока ПозицияЮникод > 0 Цикл
		
		Маска = Сред( Стр, ПозицияЮникод, 6);
		Стр = СтрЗаменить( Стр, Маска, jsonFromHEX( Сред( Маска, 3)));
		
		ПозицияЮникод = Найти( Стр, "\u");
	КонецЦикла;
	
	Возврат Стр;
	
КонецФункции // jsonUnmask
//____________________________________________________________________
Функция jsonValue( ЗначениеПараметра, ПервыйСимвол, Стр, textJSON, Смещение, ДлинаТекста, Прочитали, Ошибки)	
	
	Если ПервыйСимвол = """" Тогда // Строка
		
		Стр = Сред( Стр, 2);
		Смещение = Смещение + 1;
		
		ЗначениеПараметра = "";
		Если Лев( Стр, 1) = """" Тогда // ПустаяСтрока
			Стр = Сред( Стр, 2);
			Смещение = Смещение + 1;
			Возврат Истина;
		КонецЕсли;
		
		НайденоОкончаниеСтроки = Ложь;
		Пока НЕ НайденоОкончаниеСтроки Цикл
			
			ПозицияСимвола = Найти( Стр, """");
			НайденоОкончаниеСтроки = ПозицияСимвола > 0;
			Если НайденоОкончаниеСтроки Тогда
				
				СтрДлинаЗначениеПараметра = СтрДлина( ЗначениеПараметра);
			
				// Проверка на экранирование кавычек
				Для НПП = 1 по СтрДлинаЗначениеПараметра + ПозицияСимвола - 1 Цикл
					Если Сред( ЗначениеПараметра + Стр, СтрДлинаЗначениеПараметра + ПозицияСимвола - НПП, 1) = "\" Тогда
						НайденоОкончаниеСтроки = НЕ НайденоОкончаниеСтроки;
					Иначе
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если НайденоОкончаниеСтроки Тогда
					Прервать;
				КонецЕсли;
				
				ЗначениеПараметра = ЗначениеПараметра + Лев( Стр, ПозицияСимвола);
				Стр = Сред( Стр, ПозицияСимвола + 1);
				Смещение = Смещение + ПозицияСимвола;
				
			Иначе
				
				ЗначениеПараметра = ЗначениеПараметра + Стр;
				Смещение = Смещение + СтрДлина( Стр);
				Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			
				Если Стр = Неопределено Тогда
					Ошибки = "В конце текста не найдена закрывающая кавычка.";
					Возврат Ложь;
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла; // НЕ НайденоОкончаниеСтроки
		
		Если ПозицияСимвола > 1 Тогда 
			ЗначениеПараметра = ЗначениеПараметра + Лев( Стр, ПозицияСимвола-1);
		КонецЕсли;
		Стр = Сред( Стр, ПозицияСимвола + 1);
		Смещение = Смещение + ПозицияСимвола;
		
		ЗначениеПараметра = jsonUnmask( ЗначениеПараметра);
		
	ИначеЕсли ПервыйСимвол = "{" Тогда // Структура
		
		Стр = Сред( Стр, 2);
		Смещение = Смещение + 1;
		
		ЗначениеПараметра = Новый Структура;
		Возврат jsonStruct( ЗначениеПараметра, Стр, textJSON, Смещение, ДлинаТекста, Прочитали, Ошибки);
		
	ИначеЕсли ПервыйСимвол = "[" Тогда // Массив
		
		Стр = Сред( Стр, 2);
		Смещение = Смещение + 1;
		
		ЗначениеПараметра = Новый Массив;
		Возврат jsonArray( ЗначениеПараметра, Стр, textJSON, Смещение, ДлинаТекста, Прочитали, Ошибки);
		
	ИначеЕсли ПервыйСимвол = "n" Тогда // возможно null
		
		Если СтрДлина( Стр) < 4 Тогда
			Префикс = Стр;
			Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			Если Стр = Неопределено Тогда
				Ошибки = "Неверное значение в конце текста.";
				Возврат Ложь;
			КонецЕсли;
			Стр = Префикс + Стр;
		КонецЕсли;
		
		Если Лев( Стр, 4) <> "null" Тогда
			Ошибки = "("+Смещение+") Неверное значение.";
			Возврат Ложь;
		КонецЕсли;
		
		ЗначениеПараметра = Неопределено;
		Стр = Сред( Стр, 5);
		Смещение = Смещение + 4;
		
	ИначеЕсли ПервыйСимвол = "t" Тогда // возможно true
		
		Если СтрДлина( Стр) < 4 Тогда
			Префикс = Стр;
			Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			Если Стр = Неопределено Тогда
				Ошибки = "Неверное значение в конце текста.";
				Возврат Ложь;
			КонецЕсли;
			Стр = Префикс + Стр;
		КонецЕсли;
		
		Если Лев( Стр, 4) <> "true" Тогда
			Ошибки = "("+Смещение+") Неверное значение.";
			Возврат Ложь;
		КонецЕсли;
		
		ЗначениеПараметра = Истина;
		Стр = Сред( Стр, 5);
		Смещение = Смещение + 4;
		
	ИначеЕсли ПервыйСимвол = "f" Тогда // возможно false
		
		Если СтрДлина( Стр) < 5 Тогда
			Префикс = Стр;
			Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			Если Стр = Неопределено Тогда
				Ошибки = "Неверное значение в конце текста.";
				Возврат Ложь;
			КонецЕсли;
			Стр = Префикс + Стр;
		КонецЕсли;

		Если Лев( Стр, 5) <> "false" Тогда
			Ошибки = "("+Смещение+") Неверное значение.";
			Возврат Ложь;
		КонецЕсли;
		
		ЗначениеПараметра = Ложь;
		Стр = Сред( Стр, 6);
		Смещение = Смещение + 5;
		
	ИначеЕсли Найти( "1234567890-", ПервыйСимвол) > 0 Тогда // Число
		
		БлижнийРазделитель = Найти( Стр, ",");
		Если БлижнийРазделитель > 0 Тогда
			ДругойРазделитель = Найти( Стр, "}");
			Если ДругойРазделитель > 0 И ДругойРазделитель < БлижнийРазделитель Тогда
				БлижнийРазделитель = ДругойРазделитель;
			КонецЕсли;
			ДругойРазделитель = Найти( Стр, "]");
			Если ДругойРазделитель > 0 И ДругойРазделитель < БлижнийРазделитель Тогда
				БлижнийРазделитель = ДругойРазделитель;
			КонецЕсли;
		Иначе
			БлижнийРазделитель = Найти( Стр, "}");
			Если БлижнийРазделитель > 0 Тогда
				ДругойРазделитель = Найти( Стр, "]");
				Если ДругойРазделитель > 0 И ДругойРазделитель < БлижнийРазделитель Тогда
					БлижнийРазделитель = ДругойРазделитель;
				КонецЕсли;
			Иначе
				БлижнийРазделитель = Найти( Стр, "]");
			КонецЕсли;
		КонецЕсли;
		
		Пока БлижнийРазделитель = 0 Цикл
			
			Префикс = Стр;
			Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			Если Стр = Неопределено Тогда
				Ошибки = "Не найдена закрывающая скобка в конце текста.";
				Возврат Ложь;
			КонецЕсли;
			Стр = Префикс + Стр;
			
			БлижнийРазделитель = Найти( Стр, ",");
			Если БлижнийРазделитель > 0 Тогда
				ДругойРазделитель = Найти( Стр, "}");
				Если ДругойРазделитель > 0 И ДругойРазделитель < БлижнийРазделитель Тогда
					БлижнийРазделитель = ДругойРазделитель;
				КонецЕсли;
				ДругойРазделитель = Найти( Стр, "]");
				Если ДругойРазделитель > 0 И ДругойРазделитель < БлижнийРазделитель Тогда
					БлижнийРазделитель = ДругойРазделитель;
				КонецЕсли;
			Иначе
				БлижнийРазделитель = Найти( Стр, "}");
				Если БлижнийРазделитель > 0 Тогда
					ДругойРазделитель = Найти( Стр, "]");
					Если ДругойРазделитель > 0 И ДругойРазделитель < БлижнийРазделитель Тогда
						БлижнийРазделитель = ДругойРазделитель;
					КонецЕсли;
				Иначе
					БлижнийРазделитель = Найти( Стр, "]");
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		// Попытка быстрого преобразования
		Попытка
			ЗначениеПараметра = Число( Лев( Стр, БлижнийРазделитель - 1));
			
			Стр = Сред( Стр, БлижнийРазделитель);
			Смещение = Смещение + БлижнийРазделитель - 1;
			
		Исключение
			
			// Долгое преобразование к числу
			Мантисса = "";
			Порядок = "";
			Если ПервыйСимвол = "-" Тогда
				Стр = Сред( Стр, 2);
				Мантисса = "-";
			КонецЕсли;
			
			БылаТочка = Ложь;
			Пока НЕ ПустаяСтрока( Стр) Цикл
				
				Цифра = Лев( Стр, 1);
				Если Найти( "1234567890", Цифра) > 0 Тогда
					
					Если ПустаяСтрока( Порядок) Тогда
						Мантисса = Мантисса + Цифра;
					Иначе
						Порядок = Порядок + Цифра; 
					КонецЕсли;
					
				ИначеЕсли Цифра = "." Тогда
					
					Если БылаТочка Тогда
						Ошибки = "("+Смещение+") Неверный формат числа.";
						Возврат Ложь;
					КонецЕсли;
					
					Мантисса = Мантисса + Цифра;
					БылаТочка = Истина;
					
				ИначеЕсли Цифра = "e" ИЛИ Цифра = "E" Тогда
					
					Если НЕ ПустаяСтрока( Порядок) Тогда
						Ошибки = "("+Смещение+") Неверный формат числа.";
						Возврат Ложь;
					КонецЕсли;
					
					Порядок = Порядок + Цифра;
					
				ИначеЕсли Цифра = "-" ИЛИ Цифра = "+" Тогда
					
					Если СтрДлина( Порядок) <> 1 Тогда
						Ошибки = "("+Смещение+") Неверный формат числа.";
						Возврат Ложь;
					КонецЕсли;
					
					Порядок = Порядок + Цифра;
					
				Иначе
					Прервать;
				КонецЕсли;
				
				Стр = Сред( Стр, 2);
			КонецЦикла;
			
			Попытка
				ЗначениеПараметра = Число( Мантисса) * ?( ПустаяСтрока( Порядок), 1, Pow( 10, Число( Сред( Порядок, 2))));
			Исключение
				Ошибки = "("+Смещение+") Неверный формат числа.";
				Возврат Ложь;
			КонецПопытки;
			
			Смещение = Смещение + СтрДлина( Мантисса + Порядок);
			
		КонецПопытки;
		
	Иначе
		
		Ошибки = "("+Смещение+") Неверное значение.";
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;

КонецФункции // jsonValue
//____________________________________________________________________
Функция jsonArray( НовыйМассив, Стр, textJSON, Смещение, ДлинаТекста, Прочитали, Ошибки)
	
	Пока Истина Цикл
		
		//Состояние( "Обработано " + Окр( 100*Смещение/ДлинаТекста) + "%");
	
		// Ищем начало значения элемента массива
		Пока ПустаяСтрока( Стр) Цикл
			
			Смещение = Смещение + СтрДлина( Стр);
			Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			
			Если Стр = Неопределено Тогда
				Ошибки = "В конце текста не найдена закрывающая скобка массива.";
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		ДлинаСтр = СтрДлина( Стр);
		Стр = СокрЛ( Стр);
		Смещение = Смещение + (ДлинаСтр - СтрДлина( Стр));
		
		ПервыйСимвол = Лев( Стр, 1);
		Если ПервыйСимвол = "]" Тогда // Окончание массива
			
			Стр = Сред( Стр, 2);
			Смещение = Смещение + 1;
			Возврат Истина;
			
		ИначеЕсли ПервыйСимвол = "," Тогда
			
			Ошибки = "("+Смещение+") Пустое значение элемента массива.";
			Продолжить;
		КонецЕсли;
		
		ЗначениеЭлемента = Неопределено;
		Если НЕ jsonValue( ЗначениеЭлемента, ПервыйСимвол, Стр, textJSON, Смещение, ДлинаТекста, Прочитали, Ошибки) Тогда
			Возврат Ложь;
		КонецЕсли;
		НовыйМассив.Добавить( ЗначениеЭлемента);
		
		// Ищем конец массива или разделитель элементов запятую 
		Пока ПустаяСтрока( Стр) Цикл
			
			Смещение = Смещение + СтрДлина( Стр);
			Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			
			Если Стр = Неопределено Тогда
				Ошибки = "В конце текста не найдена закрывающая скобка массива.";
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		ДлинаСтр = СтрДлина( Стр);
		Стр = СокрЛ( Стр);
		Смещение = Смещение + (ДлинаСтр - СтрДлина( Стр));
		
		ПервыйСимвол = Лев( Стр, 1);
		Если ПервыйСимвол = "]" Тогда // Окончание массива
			
			Стр = Сред( Стр, 2);
			Смещение = Смещение + 1;
			Возврат Истина;
			
		ИначеЕсли ПервыйСимвол <> "," Тогда
		
			Ошибки = "("+Смещение+") Не найден разделитель или окончание массива.";
			Возврат Ложь;
		КонецЕсли;
		
		Стр = Сред( Стр, 2);
		Смещение = Смещение + 1;
		
	КонецЦикла; // Пока Истина Цикл
	
КонецФункции // jsonArray
//____________________________________________________________________
Функция jsonStruct( НоваяСтруктура, Стр, textJSON, Смещение, ДлинаТекста, Прочитали, Ошибки)
	
	Пока Истина Цикл
		
		// Ищем открывающую кавычку идентификатора параметра структуры
		Пока ПустаяСтрока( Стр) Цикл
			
			Смещение = Смещение + СтрДлина( Стр);
			Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			
			Если Стр = Неопределено Тогда
				Ошибки = "В конце текста не найдена закрывающая скобка структуры.";
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		ДлинаСтр = СтрДлина( Стр);
		Стр = СокрЛ( Стр);
		Смещение = Смещение + (ДлинаСтр - СтрДлина( Стр));
		
		ПервыйСимвол = Лев( Стр, 1);
		Если ПервыйСимвол = "}"	Тогда // Окончание структуры
			
			Стр = Сред( Стр, 2);
			Смещение = Смещение + 1;
			Возврат Истина;
			
		ИначеЕсли ПервыйСимвол <> """" Тогда
			
			Ошибки = "("+Смещение+") Идентификатор параметра структуры без кавычек.";
			Возврат Ложь;
		КонецЕсли;
		
		Стр = Сред( Стр, 2);
		Смещение = Смещение + 1;
		
		// Ищем закрывающую кавычку идентификатора параметра структуры
		ИмяПараметра = "";
		НайденоОкончаниеСтроки = Ложь;
		Пока НЕ НайденоОкончаниеСтроки Цикл
			
			ПозицияСимвола = Найти( Стр, """");
			НайденоОкончаниеСтроки = ПозицияСимвола > 0;
			Если НайденоОкончаниеСтроки Тогда
				
				СтрДлинаИмяПараметра = СтрДлина( ИмяПараметра);
			
				// Проверка на экранирование кавычек
				Для НПП = 1 по СтрДлинаИмяПараметра + ПозицияСимвола - 1 Цикл
					Если Сред( ИмяПараметра + Стр, СтрДлинаИмяПараметра + ПозицияСимвола - НПП, 1) = "\" Тогда
						НайденоОкончаниеСтроки = НЕ НайденоОкончаниеСтроки;
					Иначе
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если НайденоОкончаниеСтроки Тогда
					Прервать;
				КонецЕсли;
				
				ИмяПараметра = ИмяПараметра + Лев( Стр, ПозицияСимвола);
				Стр = Сред( Стр, ПозицияСимвола + 1);
				Смещение = Смещение + ПозицияСимвола;
				
			Иначе
				
				ИмяПараметра = ИмяПараметра + Стр;
				Смещение = Смещение + СтрДлина( Стр);
				Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			
				Если Стр = Неопределено Тогда
					Ошибки = "В конце текста не найдена закрывающая кавычка идентификатора параметра структуры.";
					Возврат Ложь;
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла; // НЕ НайденоОкончаниеСтроки
		
		Если ПозицияСимвола > 1 Тогда 
			ИмяПараметра = ИмяПараметра + Лев( Стр, ПозицияСимвола-1);
		КонецЕсли;
		Стр = Сред( Стр, ПозицияСимвола + 1);
		Смещение = Смещение + ПозицияСимвола;
		
		ИмяПараметра = jsonUnmask( ИмяПараметра);
		
		// Ищем разделитель идентификатора и значения параметра структуры символ :
		Пока ПустаяСтрока( Стр) Цикл
			
			Смещение = Смещение + СтрДлина( Стр);
			Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			
			Если Стр = Неопределено Тогда
				Ошибки = "В конце текста не найден разделитель параметра структуры.";
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		ДлинаСтр = СтрДлина( Стр);
		Стр = СокрЛ( Стр);
		Смещение = Смещение + (ДлинаСтр - СтрДлина( Стр));
		
		Если Лев( Стр, 1) <> ":" Тогда
			Ошибки = "("+Смещение+") Не найден разделитель параметра структуры.";
			Возврат Ложь;
		КонецЕсли;
		
		Стр = Сред( Стр, 2);
		Смещение = Смещение + 1;
		
		// Ищем начало значения параметра структуры
		Пока ПустаяСтрока( Стр) Цикл
			
			Смещение = Смещение + СтрДлина( Стр);
			Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			
			Если Стр = Неопределено Тогда
				Ошибки = "В конце текста не найдена закрывающая скобка структуры.";
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		ДлинаСтр = СтрДлина( Стр);
		Стр = СокрЛ( Стр);
		Смещение = Смещение + (ДлинаСтр - СтрДлина( Стр));
		
		ПервыйСимвол = Лев( Стр, 1);
		Если ПервыйСимвол = "}" ИЛИ ПервыйСимвол = "," Тогда
			Ошибки = "("+Смещение+") Не указано значение параметра структуры.";
			Возврат Ложь;
		КонецЕсли;
		
		ЗначениеПараметра = Неопределено;
		Если НЕ jsonValue( ЗначениеПараметра, ПервыйСимвол, Стр, textJSON, Смещение, ДлинаТекста, Прочитали, Ошибки) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		ИмяПараметра = СтрЗаменить(ИмяПараметра, "-", "_");
		ИмяПараметра = СтрЗаменить(ИмяПараметра, " ", "_");
		
		Попытка
			НоваяСтруктура.Вставить( ИмяПараметра, ЗначениеПараметра);
		Исключение
			НоваяСтруктура.Вставить( "_" + ИмяПараметра, ЗначениеПараметра);
		КонецПопытки;	
		
		// Ищем ищем следующий атрибут или окончание структуры 
		Пока ПустаяСтрока( Стр) Цикл
			
			Смещение = Смещение + СтрДлина( Стр);
			Стр = ЧтениеТекстаПрочитать( textJSON, ДлинаТекста, Прочитали);
			
			Если Стр = Неопределено Тогда
				Ошибки = "В конце текста не найдена закрывающая скобка структуры.";
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		ДлинаСтр = СтрДлина( Стр);
		Стр = СокрЛ( Стр);
		Смещение = Смещение + (ДлинаСтр - СтрДлина( Стр));
		
		ПервыйСимвол = Лев( Стр, 1);
		Если ПервыйСимвол = "}" Тогда // Конец структуры
			
			Стр = Сред( Стр, 2);
			Смещение = Смещение + 1;
			Возврат Истина;
			
		ИначеЕсли ПервыйСимвол <> "," Тогда
			
			Ошибки = "("+Смещение+") Не найден разделитель или окончание структуры.";
			Возврат Ложь;
		КонецЕсли;
		
		Стр = Сред( Стр, 2);
		Смещение = Смещение + 1;
		
	КонецЦикла; // Пока Истина Цикл
	
КонецФункции // jsonStruct
//____________________________________________________________________
Процедура jsonДобавитьСтроку( Стр, Результат, ЗаписьТекста)
	
	Если ПустаяСтрока( Стр) Тогда
		Возврат;
	КонецЕсли;
	
	Результат = Результат + Стр;
	Если СтрДлина( Результат) > 500 Тогда
		ЗаписьТекста.Записать( Результат);
		Результат = "";
	КонецЕсли;
	
КонецПроцедуры // jsonДобавитьСтроку
//____________________________________________________________________
Функция jsonStringify( ЗначениеПараметра, Результат, ЗаписьТекста, Ошибки)
	
	Если ЗначениеПараметра = Неопределено ИЛИ ЗначениеПараметра = NULL Тогда
		
		Результат = Результат + "null";
		Возврат Истина;
		
	ИначеЕсли ТипЗнч( ЗначениеПараметра) = Тип("Булево") Тогда
	
		Если ЗначениеПараметра = Истина Тогда
		
			Результат = Результат + "true";
			Возврат Истина;
		
		ИначеЕсли ЗначениеПараметра = Ложь Тогда
		
			Результат = Результат + "false";
			Возврат Истина;
			
		Иначе
			
			Ошибки = "Неверное значение Булево: " + ЗначениеПараметра;
		КонецЕсли;
		
	ИначеЕсли ТипЗнч( ЗначениеПараметра) = Тип("Дата") Тогда
		
		Результат = Результат + """" + Формат( ЗначениеПараметра,  "ДФ=""гггг-ММ-ддTЧЧ:мм:ссZ""") + """";
		Возврат Истина;
		
	ИначеЕсли ТипЗнч( ЗначениеПараметра) = Тип("Число") Тогда
		
		Результат = Результат + Формат( ЗначениеПараметра, "ЧРД=.; ЧН=0; ЧГ=0");
		Возврат Истина;
		
	ИначеЕсли ТипЗнч( ЗначениеПараметра) = Тип("Строка") Тогда
		
		Стр = СтрЗаменить( ЗначениеПараметра, "\", "\\");
		Стр = СтрЗаменить( Стр, """", "\""");
		Стр = СтрЗаменить( Стр, Символы.ПС, "\n");
		Стр = СтрЗаменить( Стр, Символы.ВК, "\r");
		Стр = СтрЗаменить( Стр, Символы.Таб, "\t");
		Стр = СтрЗаменить( Стр, Символ(12), "\f");
		
		jsonДобавитьСтроку( """" + Стр + """", Результат, ЗаписьТекста);
		Возврат Истина;
		
	ИначеЕсли ТипЗнч( ЗначениеПараметра) = Тип("Структура") ИЛИ ТипЗнч( ЗначениеПараметра) = Тип("Соответствие") Тогда
		
		jsonДобавитьСтроку( "{", Результат, ЗаписьТекста);
		НуженРазделитель = Ложь;
		Для Каждого Пара из ЗначениеПараметра Цикл
			
			Если НуженРазделитель Тогда
				Результат = Результат + ",";
			Иначе
				НуженРазделитель = Истина;
			КонецЕсли;
			
			jsonДобавитьСтроку( """" + Пара.Ключ + """:" , Результат, ЗаписьТекста);
			jsonStringify( Пара.Значение, Результат, ЗаписьТекста, Ошибки);
		КонецЦикла;
		jsonДобавитьСтроку( "}", Результат, ЗаписьТекста);
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч( ЗначениеПараметра) = Тип("Массив") Тогда
		
		jsonДобавитьСтроку( "[", Результат, ЗаписьТекста);
		НуженРазделитель = Ложь;
		Для Каждого ЗначениеЭлемента из ЗначениеПараметра Цикл
			
			Если НуженРазделитель Тогда
				Результат = Результат + ",";
			Иначе
				НуженРазделитель = Истина;
			КонецЕсли;
			
			jsonStringify( ЗначениеЭлемента, Результат, ЗаписьТекста, Ошибки);
		КонецЦикла;
		jsonДобавитьСтроку( "]", Результат, ЗаписьТекста);
		
		Возврат Истина;
		
	Иначе
		
		Ошибки = "Для значений типа '" + ТипЗнч( ЗначениеПараметра) + "' сериализация не предусмотрена.";
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции // jsonStringify
//____________________________________________________________________
// 1C:JSON Parser AkiTorg 15/02/2017


// 1С:JSON. JavaScript Object Notation парсер и сериализатор.
// Copyright © 2010-2012 Александр Переверзев

// ─────────────────────────────────────────────────────────────────────────────
//  НАСТРОЙКИ

// Функция управляющая настройкой "АвтоматическоеПриведениеОбъектаКСтруктуре".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется автоматическое приведение объекта к структуре; 
//		- Ложь - автоматическое приведение объекта к структуре не выполняется, все объекты преобразуются в соответствие. 
//
// Примечание:
//  Автоматическое приведение к структуре выполняется только для объектов имена свойств которых могут быть 
//  использованы как ключи структуры, все остальные объекты преобразуются в соответствие.
//
Функция НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре()
	
	Возврат Истина;	// Измените для использования автоматического приведения объекта к структуре.
	
КонецФункции // НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре()

// Функция управляющая настройкой "ПолноеМаскированиеСимволов".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется полное маскирование символов некорректно обрабатываемых JavaScript-ом; 
//		- Ложь - маскирование выполняется только согласно стандарту и дополнительно маскируются специальные символы. 
//
// Примечание:
//	Маскирование специальных символов из диапазона [0x0000, 0x001f] выполняется в не зависимости от настройки.
//
Функция НастройкаПолноеМаскированиеСимволов()
	
	Возврат Истина;	// Измените для неполного маскирования символов.
	
КонецФункции // НастройкаПолноеМаскированиеСимволов()

// Функция управляющая настройкой "НеявноеПриведениеПримитивныхЗначенийКлюча".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется неявное приведение примитивных типов значений ключей соответствий к их строковому представлению в формате 1С; 
//		- Ложь - неявное приведение примитивных типов значений ключей соответствий к строковому представлению не выполняется. 
//
// Примечание:
//	Неявно приводимые типы: Null, Булево, Число, Дата, Строка, УникальныйИдентификатор.
//
Функция НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча()
	
	Возврат Истина;	// Измените для использования неявного приведения примитивных значений ключей соответствий к строке.
	
КонецФункции // НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча()



// JSON парсер.
//
// Параметры:
//	Значение - Строка. Строка данных в формате JSON для парсинга;
//
//  Стандарт - Неопределено, Булево. Режим работы:
//		- Истина - стандартный режим (значение по умолчанию);
//		- Ложь - альтернативный режим;
//		- Неопределено - автоопределение режима;
//
//  ПредставленияСсылок - Неопределено, Булево. Режим передачи ссылочных типов, с их представлением или без:
//		- Истина - ссылки передаются вместе со своим представлением, как объекты с двумя свойствами содержащими саму ссылку и ее представление;
//		- Ложь - ссылки передаются без представления (значение по умолчанию).
//		- Неопределено - автоопределение режима.
// 
// Возвращаемое значение:
//  Набор данных согласно содержимому входящих данных. 
//
Функция ПрочитатьСтрокуJSON(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь) Экспорт 
	
	Возврат jsonПрочитатьИнициализация(Значение, Стандарт, ПредставленияСсылок);
	
КонецФункции // ПрочитатьJSON()

// JSON сериализатор.
//
// Параметры:
//	Значение. Набор данных сериализуемых в формат JSON;
//
//  Стандарт - Булево. Режим работы:
//		- Истина - стандартный режим (значение по умолчанию);
//		- Ложь - альтернативный режим;
//
//  ПредставленияСсылок - Булево. Режим передачи ссылочных типов, с их представлением или без:
//		- Истина - ссылки передаются вместе со своим представлением, как объекты с двумя свойствами содержащими саму ссылку и ее представление;
//		- Ложь - ссылки передаются без представления (значение по умолчанию).
// 
// Возвращаемое значение:
//  Строка. Строка данных в формате JSON согласно содержимому входящих данных. 
//
Функция ЗаписатьСтрокуJSON(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь) Экспорт 
	
	Возврат jsonЗаписатьИнициализация(Значение, Стандарт, ПредставленияСсылок);
	
КонецФункции // ЗаписатьJSON()


// ─────────────────────────────────────────────────────────────────────────────
//  ПАРСЕР

Функция jsonПрочитатьИнициализация(Значение, Стандарт, ПредставленияСсылок)
	
	// Проверка параметров.
	Если (Не Стандарт = Истина) И (Не Стандарт = Ложь) И (Не Стандарт = Неопределено) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("Стандарт"); КонецЕсли; 
	Если (Не ПредставленияСсылок = Истина) И (Не ПредставленияСсылок = Ложь) И (Не ПредставленияСсылок = Неопределено) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("ПредставленияСсылок"); КонецЕсли; 
	
	// Схема подстановок шестнадцатиричной системы.
	СхемаПодстановок = Новый Соответствие; ШестнадцатиричнаяСистема = "0123456789abcdef"; ДесятичноеЧисло = 0;
	Для ВторойРазряд = 1 По 16 Цикл Для ПервыйРазряд = 1 По 16 Цикл СхемаПодстановок.Вставить(Сред(ШестнадцатиричнаяСистема, ВторойРазряд, 1) + Сред(ШестнадцатиричнаяСистема, ПервыйРазряд, 1), ДесятичноеЧисло); ДесятичноеЧисло = ДесятичноеЧисло + 1; КонецЦикла; КонецЦикла;
	
	// Вспомогательные данные.
	ВспомогательныеДанные = Новый Структура("ТипСтроки,СхемаПодстановок,АвтоматическиПриводитьКСтруктуре",
		Тип("Строка"),
		СхемаПодстановок,
		(НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре() = Истина));
		
	// Стартовые значения.
	Индекс = 1; Длина = СтрДлина(Значение);
	
	// Форматирование (первый шаг парсера).
	Если (Стандарт = Истина) Или (Стандарт = Неопределено) Тогда СимволыФорматирования = " " + Символы.ВК + Символы.ПС + Символы.Таб; jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); Иначе СимволыФорматирования = ""; КонецЕсли;
	Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеПустойПакетДанных(); КонецЕсли; 
	
	// Парсер.
	Возврат jsonПрочитать(Значение, Стандарт, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Истина);
	
КонецФункции // jsonПрочитатьИнициализация()

Функция jsonПрочитать(Значение, Стандарт, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, ПервыйУровень)
	
	Символ = Сред(Значение, Индекс, 1);
	Если (Символ = "[") Тогда																								// [
		
		// Массив.
		Результат = Новый Массив;
		
		Индекс = Индекс + 1; jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеМассива(Длина); КонецЕсли;
		Символ = Сред(Значение, Индекс, 1); Если (Символ = "]") Тогда														// ] 
			
			// Пустой массив.
			Индекс = Индекс + 1;
		
		Иначе
		
			Пока (Индекс <= Длина) Цикл
				
				// Значение.
				Результат.Добавить(jsonПрочитать(Значение, Стандарт, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь));
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = "]") Тогда																					// ]
					// Окончание массива.
					Индекс = Индекс + 1; Прервать;
				Иначе
					// Продолжение массива.
					Если (Символ = ",") Тогда																				// ,
						Индекс = Индекс + 1; jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); Если (Индекс >= Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеМассива(Длина); КонецЕсли;
					Иначе
						ВызватьИсключение ИсключениеНедопустимыйСимвол(Индекс, ",");
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	ИначеЕсли (Символ = "{") Тогда																							// {
	
		// Объект.
		
		Индекс = Индекс + 1; jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеМассива(Длина); КонецЕсли;
		Символ = Сред(Значение, Индекс, 1); Если (Символ = "}") Тогда														// } 
			
			// Пустой объект.
			Индекс = Индекс + 1;
			
			ТолькоДопустимыеСтроки = ВспомогательныеДанные.АвтоматическиПриводитьКСтруктуре; Если ТолькоДопустимыеСтроки Тогда РезультатСтруктура = Новый Структура; Иначе РезультатСоответствие = Новый Соответствие; КонецЕсли;
		
		Иначе
			
			ТолькоДопустимыеСтроки = ВспомогательныеДанные.АвтоматическиПриводитьКСтруктуре; РезультатСоответствие = Новый Соответствие; Если ТолькоДопустимыеСтроки Тогда РезультатСтруктура = Новый Структура; КонецЕсли; ТипСтроки = ВспомогательныеДанные.ТипСтроки;
			
			Пока (Индекс <= Длина) Цикл
				
				// Ключ.
				Начало = Индекс; КлючЭлемента = jsonПрочитать(Значение, Стандарт, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь); Если (Не ТипЗнч(КлючЭлемента) = ТипСтроки) Тогда ВызватьИсключение ИсключениеНедопустимыйТипКлюча(Начало, КлючЭлемента); КонецЕсли;
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = ":") Тогда																					// :
					Индекс = Индекс + 1; jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); Если (Индекс >= Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеОбъетка(Длина); КонецЕсли;
				Иначе
					ВызватьИсключение ИсключениеНедопустимыйСимвол(Индекс, ":");
				КонецЕсли;
				
				// Значение.
				ЗначениеЭлемента = jsonПрочитать(Значение, Стандарт, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь);
				
				// Коллекция.
				РезультатСоответствие.Вставить(КлючЭлемента, ЗначениеЭлемента);
				Если ТолькоДопустимыеСтроки Тогда Попытка РезультатСтруктура.Вставить(КлючЭлемента, ЗначениеЭлемента); Исключение ТолькоДопустимыеСтроки = Ложь; КонецПопытки; КонецЕсли;
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = "}") Тогда																					// }
					// Окончание объекта.
					Индекс = Индекс + 1; Прервать;
				Иначе
					// Продолжение объекта.
					Если (Символ = ",") Тогда																				// ,
						Индекс = Индекс + 1; jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); Если (Индекс >= Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеОбъетка(Длина); КонецЕсли;
					Иначе
						ВызватьИсключение ИсключениеНедопустимыйСимвол(Индекс, ",");
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;	
		
		КонецЕсли;
		
		// Структуры.
		Если ТолькоДопустимыеСтроки Тогда   
			Результат = РезультатСтруктура; 
		Иначе
			Результат = РезультатСоответствие;
		КонецЕсли;
		
		// Ссылка.
		Если (ПредставленияСсылок = Истина) Или (ПредставленияСсылок = Неопределено) Тогда Результат = jsonПрочитатьСсылку(Результат, ТолькоДопустимыеСтроки); КонецЕсли;
		
	Иначе
	
		// Примитивные типы.
		Если (Символ = """") Или (Символ = "'") Тогда        																// " , '
			
			// Строка.
			Подстрока = Сред(Значение, Индекс + 1); Начало = Индекс; Пока Истина Цикл
				Позиция = Найти(Подстрока, Символ);
				
				Если (Позиция > 0) Тогда
					Индекс = Индекс + Позиция; Откат = Позиция - 1; Маскировка = Ложь; Пока (Сред(Подстрока, Откат, 1) = "\") И Булево(Откат) Цикл Маскировка = Не Маскировка; Откат = Откат - 1; КонецЦикла;
					Если Маскировка Тогда Подстрока = Сред(Подстрока, Позиция + 1); Иначе Прервать; КонецЕсли;
				Иначе
			  		ВызватьИсключение ИсключениеНеожиданноеОкончаниеПакетаДанных();
				КонецЕсли;
				
			КонецЦикла;
			
			// Строка.
			Результат = jsonПрочитатьСтроку(Сред(Значение, Начало + 1, Индекс - Начало - 1), Стандарт, Начало, ВспомогательныеДанные.СхемаПодстановок, (Символ = "'"));
			
			Если jsonПрочитатьОпределитьДату(Результат) Тогда
				// Дата.
				Результат = jsonПрочитатьДату(Результат, Начало);
			ИначеЕсли jsonПрочитатьОпределитьИдентификатор(Результат) Тогда
				// Идентификатор.
				Результат = jsonПрочитатьИдентификатор(Результат, Начало);
			ИначеЕсли (Стандарт = Ложь) Или (Стандарт = Неопределено) Тогда
				Если jsonПрочитатьОпределитьВнутреннийТип(Результат) Тогда
					// Внутренний тип.
					Результат = jsonПрочитатьВнутреннийТип(Результат, Начало);
				КонецЕсли;
			КонецЕсли;
			
			// Корректировка индекса.
			Индекс = Индекс + 1;
			
		Иначе
			
			Если (Символ = "n") Тогда
				
				// Null.
				Если (Сред(Значение, Индекс, 4) = "null") Тогда Индекс = Индекс + 4; Результат = Null; Иначе ВызватьИсключение ИсключениеНекорректныйТипNull(Индекс); КонецЕсли;
				
			ИначеЕсли (Символ = "t") Тогда
				
				// Истина.
				Если (Сред(Значение, Индекс, 4) = "true") Тогда Индекс = Индекс + 4; Результат = Истина; Иначе ВызватьИсключение ИсключениеНекорректныйТипБулево(Индекс); КонецЕсли;
				
			ИначеЕсли (Символ = "f") Тогда
				
				// Ложь.
				Если (Сред(Значение, Индекс, 5) = "false") Тогда Индекс = Индекс + 5; Результат = Ложь; Иначе ВызватьИсключение ИсключениеНекорректныйТипБулево(Индекс); КонецЕсли;
				
			ИначеЕсли (Символ = "u") Тогда
				
				// Неопределено.
				Если (Сред(Значение, Индекс, 9) = "undefined") Тогда Индекс = Индекс + 9; Результат = Неопределено; Иначе ВызватьИсключение ИсключениеНекорректныйТипНеопределено(Индекс); КонецЕсли;
				
			Иначе
				
				// Число.
				Начало = Индекс; Пока Булево(Найти("-+0123456789.", Символ)) И (Индекс <= Длина) Цикл Индекс = Индекс + 1; Символ = Сред(Значение, Индекс, 1); КонецЦикла;
				
				// Преобразование числа.
				Попытка
					Результат = Строка(Сред(Значение, Начало, Индекс - Начало));
					//Результат = Число(Сред(Значение, Начало, Индекс - Начало));
				Исключение
					ВызватьИсключение ИсключениеНекорректныйФорматЧисла(Начало, Сред(Значение, Начало, Индекс - Начало)); 
				КонецПопытки;
				
				// Экспоненциальная часть.
				Если (Символ = "E") Или (Символ = "e") Тогда
					
					// Степень.
					Индекс = Индекс + 1; Позиция = Индекс; Символ = Сред(Значение, Индекс, 1); Пока Булево(Найти("-+0123456789", Символ)) И (Индекс <= Длина) Цикл Индекс = Индекс + 1; Символ = Сред(Значение, Индекс, 1); КонецЦикла;
					
					// Преобразование степени.
					Попытка
						Степень = Число(Сред(Значение, Позиция, Индекс - Позиция));
					Исключение
						ВызватьИсключение ИсключениеНекорректныйФорматЧисла(Начало, Сред(Значение, Начало, Индекс - Начало)); 
					КонецПопытки;
					
					// Возвидение числа в степень.
					Результат = Результат * Pow(10, Степень);
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Форматирование.
	jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); Если ПервыйУровень Тогда Если (Индекс <= Длина) Тогда ВызватьИсключение ИсключениеНекорректныйПакетДанных(Индекс); КонецЕсли; Иначе Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеПакетаДанных(); КонецЕсли; КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // jsonПрочитать()

Функция jsonПрочитатьОпределитьДату(Значение)

	// Проверка.
	Если (СтрДлина(Значение) = 20) Тогда
		Если (Сред(Значение, 05, 1) = "-") И				// -
			 (Сред(Значение, 08, 1) = "-") И				// -
			 (Сред(Значение, 11, 1) = "T") И				// T
			 (Сред(Значение, 14, 1) = ":") И				// :
			 (Сред(Значение, 17, 1) = ":") И				// :
			 (Сред(Значение, 20, 1) = "Z") Тогда			// Z
			// Год. 
			Если Булево(Найти("0123456789", Сред(Значение, 01, 1))) И
				 Булево(Найти("0123456789", Сред(Значение, 02, 1))) И
				 Булево(Найти("0123456789", Сред(Значение, 03, 1))) И
				 Булево(Найти("0123456789", Сред(Значение, 04, 1))) И
			// Месяц.
				 Булево(Найти("0123456789", Сред(Значение, 06, 1))) И
				 Булево(Найти("0123456789", Сред(Значение, 07, 1))) И
			// День.
				 Булево(Найти("0123456789", Сред(Значение, 09, 1))) И
				 Булево(Найти("0123456789", Сред(Значение, 10, 1))) И
			// Час.
				 Булево(Найти("0123456789", Сред(Значение, 12, 1))) И
				 Булево(Найти("0123456789", Сред(Значение, 13, 1))) И
			// Минута.
				 Булево(Найти("0123456789", Сред(Значение, 15, 1))) И
				 Булево(Найти("0123456789", Сред(Значение, 16, 1))) И
			// Секунда.
				 Булево(Найти("0123456789", Сред(Значение, 18, 1))) И
				 Булево(Найти("0123456789", Сред(Значение, 19, 1))) Тогда
				Возврат Истина; 
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции // jsonПрочитатьОпределитьДату()

Функция jsonПрочитатьОпределитьИдентификатор(Значение)

	// Проверка.
	Если (СтрДлина(Значение) = 36) Тогда
		Если (Сред(Значение, 09, 1) = "-") И					// -
			 (Сред(Значение, 14, 1) = "-") И					// -
			 (Сред(Значение, 19, 1) = "-") И					// -
			 (Сред(Значение, 24, 1) = "-") Тогда				// -
			// Первая часть. 
			Для Индекс = 01 По 08 Цикл Если Не Булево(Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1))) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Вторая часть. 
			Для Индекс = 10 По 13 Цикл Если Не Булево(Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1))) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Третья часть. 
			Для Индекс = 15 По 18 Цикл Если Не Булево(Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1))) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Четвертая часть. 
			Для Индекс = 20 По 23 Цикл Если Не Булево(Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1))) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Пятая часть. 
			Для Индекс = 25 По 36 Цикл Если Не Булево(Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1))) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции // jsonПрочитатьОпределитьИдентификатор()

Функция jsonПрочитатьОпределитьВнутреннийТип(Значение)
	
	// Поиск.
	Возврат (Лев(Значение, 1) = "¦") И (Сред(Значение, 5, 1) = "¦") И (Прав(Значение, 1) = "¦"); // ¦xxx¦ ... ¦
	
КонецФункции // jsonПрочитатьОпределитьВнутреннийТип()

Функция jsonПрочитатьСтроку(Значение, Стандарт, Индекс, СхемаПодстановок, ОдинарнаяКавычка)
	
	// Последоавтельность перемаскировки.
	ПоследоавтельностьПеремаскировки = "\" + Символ(65535);
	
	// Демаскирование служебных символов.
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение, 
						"\\",			ПоследоавтельностьПеремаскировки),		// Перемаскирование последовательности.
						"\/",			"/"),           // x2f
						"\b",			Символ(008)),	// x08
						"\t",			Символы.Таб),   // x09
						"\n",			Символы.ПС),    // x0a
						"\f",			Символы.ПФ),    // x0c
						"\r",			Символы.ВК),    // x0d
						"\""",			"""");          // x22
						
	// Демаскирование Юникод символов.
	Позиция = Найти(Результат, "\u"); Пока Булево(Позиция) Цикл
		СтаршийБайт = СхемаПодстановок[НРег(Сред(Результат, Позиция + 2, 2))]; МладшийБайт = СхемаПодстановок[НРег(Сред(Результат, Позиция + 4, 2))]; Если (СтаршийБайт = Неопределено) Или (МладшийБайт = Неопределено) Тогда ВызватьИсключение ИсключениеНекорректныйФорматСтроки(Индекс); КонецЕсли;
		Результат = СтрЗаменить(Результат, Сред(Результат, Позиция, 6), Символ(256 * СтаршийБайт + МладшийБайт)); Позиция = Найти(Результат, "\u");
	КонецЦикла;
		
	// Одинарная кавычка.
	Если ОдинарнаяКавычка Тогда Результат = СтрЗаменить(Результат, "\'", "'"); КонецЕсли;
	
	// Демаскирование перемаскированой последовательности.
	Возврат СтрЗаменить(Результат, ПоследоавтельностьПеремаскировки, "\");				
						
КонецФункции // jsonПрочитатьСтроку()

Функция jsonПрочитатьДату(Значение, Индекс)
	
	// Поиск.
	Попытка
		Возврат Строка( Значение);
		//Возврат Дата(Лев(Значение, 4) + Сред(Значение, 06, 2) + Сред(Значение, 09, 2) + 
		//			 Сред(Значение, 12, 2) + Сред(Значение, 15, 2) + Сред(Значение, 18, 2));
	Исключение
		ВызватьИсключение ИсключениеНекорректныйФорматДаты(Индекс, Значение);
	КонецПопытки;
	
КонецФункции // jsonПрочитатьДату()

Функция jsonПрочитатьСсылку(Значение, Структура)
	
	Перем Ссылка;
	
	// Ссылка.
	Если (Значение.Количество() = 2) Тогда 
		Если Структура Тогда
			Если Значение.Свойство("Представление") И Значение.Свойство("Ссылка", Ссылка) Тогда Возврат Ссылка; КонецЕсли;
		Иначе
			Ссылка = Значение.Получить("Ссылка"); Если (Не Ссылка = Неопределено) И (Не Значение.Получить("Представление") = Неопределено) Тогда Возврат Ссылка; КонецЕсли;
		КонецЕсли;
	КонецЕсли;	
	
	Возврат Значение;
	
КонецФункции // jsonПрочитатьСсылку()

Функция jsonПрочитатьИдентификатор(Значение, Индекс)
	
	// Поиск.
	Попытка
		//Возврат Новый УникальныйИдентификатор(Значение);
		Возврат Строка( Значение);
	Исключение
		ВызватьИсключение ИсключениеНевозможноПреобразоватьЗначение(Индекс, Значение);
	КонецПопытки;
	
КонецФункции // jsonПрочитатьИдентификатор()

Функция jsonПрочитатьВнутреннийТип(Значение, Индекс)
#Если ВебКлиент Или ТонкийКлиент Тогда
	ВызватьИсключение ИсключениеНевозможноПреобразоватьЗначениеНаКлиенте(Индекс, Значение);
#Иначе
	
	Возврат Строка( Значение);
	//// Поиск.
	//Тип = Сред(Значение, 2, 3); Данные = Сред(Значение, 6, СтрДлина(Значение) - 6);
	//
	//Если (Тип = "ref") Тогда
	//	Попытка
	//		Возврат ЗначениеИзСтрокиВнутр("{""#""," + СтрЗаменить(СтрЗаменить(Данные, "×", ":"), "÷", ",") + "}");
	//	Исключение
	//		ВызватьИсключение ИсключениеНевозможноПреобразоватьЗначение(Индекс, Значение);
	//	КонецПопытки;
	//КонецЕсли;
		
	//ВызватьИсключение ИсключениеНеопознанныйТип(Индекс, Тип);
	
#КонецЕсли
КонецФункции // jsonПрочитатьВнутреннийТип()

Процедура jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования)
	
	// Пропуск форматирования.
	Если (Стандарт = Истина) Или (Стандарт = Неопределено) Тогда Пока (Индекс <= Длина) И Булево(Найти(СимволыФорматирования, Сред(Значение, Индекс, 1))) Цикл Индекс = Индекс + 1; КонецЦикла; КонецЕсли;
	// Пробел его не видно, \r, \n, \t .
	
КонецПроцедуры // jsonПрочитатьПропуститьФорматирование()


// ─────────────────────────────────────────────────────────────────────────────
//  СЕРИАЛИЗАТОР

Функция jsonЗаписатьИнициализация(Значение, Стандарт, ПредставленияСсылок)
	
	// Проверка параметров.
	Если (Не Стандарт = Истина) И (Не Стандарт = Ложь) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("Стандарт"); КонецЕсли; 
	Если (Не ПредставленияСсылок = Истина) И (Не ПредставленияСсылок = Ложь) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("ПредставленияСсылок"); КонецЕсли; 
	
	Типы = Новый Структура("Строка,Дата,УникальныйИдентификатор,КлючИЗначение,СписокЗначений,COMSafeArray,ТаблицаЗначений,ДеревоЗначений,КоллекцияСтрокДереваЗначений,Запрос,РезультатЗапроса,ВыборкаИзРезультатаЗапроса,Построители,ПримитивныеТипы,Массивы,Структуры,Соответсвия,ДанныеФормыДерево,КлиентскиеТипы,ТипДопустимыхКлючей", 
		Тип("Строка"),
		Тип("Дата"),
		Тип("УникальныйИдентификатор"),
		Тип("КлючИЗначение"),
		Тип("СписокЗначений"),
		Тип("COMSafeArray"),
		Тип("ТаблицаЗначений"),
		Тип("ДеревоЗначений"),
		Тип("КоллекцияСтрокДереваЗначений"),
		Тип("Запрос"),
		Тип("РезультатЗапроса"),
		Тип("ВыборкаИзРезультатаЗапроса"),
		Новый ОписаниеТипов("ПостроительЗапроса,ПостроительОтчета"),
		Новый ОписаниеТипов("Null,Булево,Число,Дата,УникальныйИдентификатор"),
		Новый ОписаниеТипов("Массив,ФиксированныйМассив,СписокЗначений,ФиксированнаяКоллекция,COMSafeArray"),
		Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура"),
		Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура,Соответствие,ФиксированноеСоответствие"),
		Тип("ДанныеФормыДерево"),
		Новый ОписаниеТипов("ДанныеФормыКоллекция,ДанныеФормыСтруктураСКоллекцией,ДанныеФормыДерево"),
		Неопределено);
		
	// Типы допустимых ключей.
	Если (НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча() = Истина) Тогда Типы.ТипДопустимыхКлючей = Новый ОписаниеТипов("Null,Булево,Число,Дата,Строка,УникальныйИдентификатор"); Иначе Типы.ТипДопустимыхКлючей = Новый ОписаниеТипов("Строка"); КонецЕсли;
		
	// форматирование.
	Если Стандарт Тогда Смещение = ""; Отступ = " "; ПереносСтроки = Символы.ПС; Иначе Смещение = ""; Отступ = ""; ПереносСтроки = ""; КонецЕсли;
	
	// Сериализация.
	Возврат jsonЗаписать(Значение, Стандарт, ПредставленияСсылок, Типы, Неопределено, Смещение, Отступ, ПереносСтроки, (Не НастройкаПолноеМаскированиеСимволов() = Истина));
	
КонецФункции // jsonЗаписатьИнициализация()

Функция jsonЗаписать(Значение, Стандарт, ПредставленияСсылок, Типы, Колонки, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов)
	
	// Определение типа.
	Тип = ТипЗнч(Значение);
		
	// Строка.
	Если (Тип = Типы.Строка) Тогда Возврат jsonЗаписатьСтроку(Значение, НеПолноеМаскированиеСимволов); КонецЕсли;
	
	// Неопределено и примитивные типы.
	Если Типы.ПримитивныеТипы.СодержитТип(Тип) Тогда 
		Если (Значение = Null) Или (Значение = Неопределено) Тогда Возврат "null"; ИначеЕсли (Тип = Типы.Дата) Тогда Возврат """" + XMLСтрока(Значение) + "Z""" ИначеЕсли (Тип = Типы.УникальныйИдентификатор) Тогда Возврат """" + XMLСтрока(Значение) + """"; Иначе Возврат XMLСтрока(Значение); КонецЕсли;
	КонецЕсли;
	
	// Массивы.
	Если Типы.Массивы.СодержитТип(Тип) Тогда
		Если Булево(Значение.Количество()) Тогда
						
			// форматирование.
			Если Стандарт Тогда СледующееСмещение = Смещение + "    "; Иначе СледующееСмещение = Смещение; КонецЕсли;
	
			Первый = Истина; Если (Тип = Типы.СписокЗначений) Тогда
				
				// Список значений.
				Структура = Новый Структура("Значение,Представление,Пометка");
				Для Каждого Элемент Из Значение Цикл
					ЗаполнитьЗначенияСвойств(Структура, Элемент);
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, Типы, Неопределено, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); Первый = Ложь;
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, Типы, Неопределено, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
					КонецЕсли;
				КонецЦикла;
				
			Иначе
				
				// Массивы.
				Для Каждого Элемент Из Значение Цикл
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Элемент, Стандарт, ПредставленияСсылок, Типы, Неопределено, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); Первый = Ложь;
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Элемент, Стандарт, ПредставленияСсылок, Типы, Неопределено, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
					КонецЕсли;
				КонецЦикла;
			
			КонецЕсли;
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
		
		Иначе
			
			// Пустой массив.
			Возврат "[" + Отступ + "]";
		
		КонецЕсли;
	КонецЕсли;
	
	// Соответсвия.
	Если Типы.Соответсвия.СодержитТип(Тип) Тогда
		Если Булево(Значение.Количество()) Тогда
						
			// форматирование.
			Если Стандарт Тогда СледующееСмещение = Смещение + "    "; Иначе СледующееСмещение = Смещение; КонецЕсли;
	
			Если Типы.Структуры.СодержитТип(Тип) Тогда
				
				КоллекцияСтрокДереваЗначений = (Не Колонки = Неопределено);
				
				// Структуры.
				Первый = Истина; Для Каждого Элемент Из Значение Цикл
					Если КоллекцияСтрокДереваЗначений И (Элемент.Ключ = "Строки") Тогда Продолжить; КонецЕсли;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, Типы, Неопределено, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); Первый = Ложь;
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, Типы, Неопределено, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
					КонецЕсли;
				КонецЦикла;
				Если КоллекцияСтрокДереваЗначений Тогда
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + """Строки"":" + Отступ + jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, Типы, Колонки, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """Строки"":" + Отступ + jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, Типы, Колонки, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
					КонецЕсли;
				КонецЕсли;
				
			Иначе
				
				ТипДопустимыхКлючей = Типы.ТипДопустимыхКлючей; ТипСтрока = Типы.Строка;
			
				// Соответсвия.
				Первый = Истина; Для Каждого Элемент Из Значение Цикл
					Ключ = Элемент.Ключ; Тип = ТипЗнч(Ключ); Если (Тип = ТипСтрока) Тогда Ключ = jsonЗаписатьСтроку(Ключ, НеПолноеМаскированиеСимволов); ИначеЕсли ТипДопустимыхКлючей.СодержитТип(Тип) Тогда Ключ = """" + Ключ + """"; Иначе ВызватьИсключение ИсключениеНедопустимыйТипКлюча(Неопределено, Ключ); КонецЕсли;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, Типы, Неопределено, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); Первый = Ложь;
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, Типы, Неопределено, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
					КонецЕсли;
				КонецЦикла;
				
			КонецЕсли;
			Возврат "{" + Результат + ПереносСтроки + Смещение + "}";
			
		Иначе
			
			// Пустое соответсвие.
			Возврат "{" + Отступ + "}";
		
		КонецЕсли;
	КонецЕсли;
	
	// Таблица значений.
	Если (Тип = Типы.ТаблицаЗначений) Тогда
		Если Булево(Значение.Количество()) Тогда
						
			// форматирование.
			Если Стандарт Тогда СледующееСмещение = Смещение + "    "; Иначе СледующееСмещение = Смещение; КонецЕсли;
	
			Структура = Новый Структура; НаборКолонок = Значение.Колонки; Для Каждого Колонка Из НаборКолонок Цикл Структура.Вставить(Колонка.Имя); КонецЦикла;
			
			Первый = Истина; Для Каждого Элемент Из Значение Цикл
				ЗаполнитьЗначенияСвойств(Структура, Элемент);
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, Типы, Неопределено, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, Типы, Неопределено, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
				КонецЕсли;
			КонецЦикла;
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
				
		Иначе
			
			// Пустая таблица значений.
			Возврат "[" + Отступ + "]";
		
		КонецЕсли;
	КонецЕсли;
	
	// Дерево значений.
	Если (Тип = Типы.ДеревоЗначений) Тогда
		
		Структура = Новый Структура("Строки"); НаборКолонок = Значение.Колонки; Для Каждого Колонка Из НаборКолонок Цикл Структура.Вставить(Колонка.Имя); КонецЦикла;
		Возврат jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, Типы, Структура, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
		
	КонецЕсли;
	Если (Тип = Типы.КоллекцияСтрокДереваЗначений) Тогда
		Если Булево(Значение.Количество()) Тогда
						
			// форматирование.
			Если Стандарт Тогда СледующееСмещение = Смещение + "    "; Иначе СледующееСмещение = Смещение; КонецЕсли;
	
			Структура = Колонки; Первый = Истина; Для Каждого Элемент Из Значение Цикл
				ЗаполнитьЗначенияСвойств(Структура, Элемент); Структура.Строки = Элемент.Строки;
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, Типы, Колонки, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, Типы, Колонки, СледующееСмещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
				КонецЕсли;
			КонецЦикла;
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
		
		Иначе
			
			// Пустая коллекция строк.
			Возврат "[" + Отступ + "]";
		
		КонецЕсли;
	КонецЕсли;

	// Запрос.
	Если (Тип = Типы.Запрос) Тогда Попытка Возврат jsonЗаписать(Значение.Выполнить().Выгрузить(), Стандарт, ПредставленияСсылок, Типы, Неопределено, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); Исключение ВызватьИсключение ИсключениеНевозможноВыполнитьЗапрос(ИнформацияОбОшибке().Причина.Описание); КонецПопытки; КонецЕсли;
	
	// Результат запроса.
	Если (Тип = Типы.РезультатЗапроса) Тогда Возврат jsonЗаписать(Значение.Выгрузить(), Стандарт, ПредставленияСсылок, Типы, Неопределено, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); КонецЕсли;
	
	// Выборка из результата запроса.
	Если (Тип = Типы.ВыборкаИзРезультатаЗапроса) Тогда
		
		Структура = Новый Структура; НаборКолонок = Значение.Владелец().Колонки; Для Каждого Колонка Из НаборКолонок Цикл Структура.Вставить(Колонка.Имя); КонецЦикла;
		ЗаполнитьЗначенияСвойств(Структура, Значение);
		Возврат jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, Типы, Неопределено, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
		
	КонецЕсли;
	
	// Построители.
	Если Типы.Построители.СодержитТип(Тип) Тогда Попытка Значение.Выполнить(); Исключение ВызватьИсключение ИсключениеНевозможноВыполнитьЗапрос(ИнформацияОбОшибке().Причина.Описание); КонецПопытки; Возврат jsonЗаписать(Значение.Результат, Стандарт, ПредставленияСсылок, Типы, Неопределено, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); КонецЕсли;
	
	// Ключ и значение.
	Если (Тип = Типы.КлючИЗначение) Тогда Возврат jsonЗаписать(Новый Структура("Ключ,Значение", Значение.Ключ, Значение.Значение), Стандарт, ПредставленияСсылок, Типы, Неопределено, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); КонецЕсли;
	
	// Клиентские типы.
	Если Типы.КлиентскиеТипы.СодержитТип(Тип) Тогда
		Если (Тип = Типы.ДанныеФормыДерево) Тогда
			Возврат jsonЗаписать(ДанныеФормыВЗначение(Значение, Типы.ДеревоЗначений), Стандарт, ПредставленияСсылок, Типы, Неопределено, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
		Иначе
			Возврат jsonЗаписать(Значение.Выгрузить(), Стандарт, ПредставленияСсылок, Типы, Неопределено, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов);
		КонецЕсли;
	КонецЕсли;
	
	// COMSafeArray.
	Если (Тип = Типы.COMSafeArray) Тогда jsonЗаписать(Значение.Выгрузить(), Стандарт, ПредставленияСсылок, Типы, Неопределено, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); КонецЕсли;
			
	// Ссылки.
	Перечисление = Перечисления.ТипВсеСсылки().СодержитТип(Тип);
	Если Перечисление Или
		 Справочники.ТипВсеСсылки().СодержитТип(Тип) Или
		 Документы.ТипВсеСсылки().СодержитТип(Тип) Или
		 ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Или
		 ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Или
		 ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Или
		 Задачи.ТипВсеСсылки().СодержитТип(Тип) Или
		 БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Или
		 БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип) Или
		 ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда 
		Возврат jsonЗаписатьСсылку(Значение, Стандарт, ПредставленияСсылок, Типы, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов, Перечисление);
	КонецЕсли;

	// Неподдерживаемые типы.
	Возврат jsonЗаписатьСтроку(Значение, НеПолноеМаскированиеСимволов);

КонецФункции // jsonЗаписать()

Функция jsonЗаписатьСтроку(Значение, НеПолноеМаскированиеСимволов)
	
	// Маскирование служебных символов.
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение, 
						"\",			"\\"),			// x5c
						"/",			"\/"),			// x2f
						Символ(008),	"\b"),			// x08
						Символы.Таб,	"\t"), 			// x09
						Символы.ПС,		"\n"),			// x0a
						Символы.ПФ,		"\f"),			// x0c
						Символы.ВК,		"\r"),			// x0d
						"""",			"\""");			// x22

	// Маскирование специальных символов.
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
						Символ(00),		"\u0000"),
						Символ(01),		"\u0001"),
						Символ(02),		"\u0002"),
						Символ(03),		"\u0003"),
						Символ(04),		"\u0004"),
						Символ(05),		"\u0005"),
						Символ(06),		"\u0006"),
						Символ(07),		"\u0007"),
						Символ(11),		"\u000b"),
						Символ(14),		"\u000e"),
						Символ(15),		"\u000f"),
						Символ(16),		"\u0010"),
						Символ(17),		"\u0011"),
						Символ(18),		"\u0012"),
						Символ(19),		"\u0013"),
						Символ(20),		"\u0014"),
						Символ(21),		"\u0015"),
						Символ(22),		"\u0016"),
						Символ(23),		"\u0017"),
						Символ(24),		"\u0018"),
						Символ(25),		"\u0019"),
						Символ(26),		"\u001a"),
						Символ(27),		"\u001b"),
						Символ(28),		"\u001c"),
						Символ(29),		"\u001d"),
						Символ(30),		"\u001e"),
						Символ(31),		"\u001f");
						
						
	Если НеПолноеМаскированиеСимволов Тогда Возврат """" + Результат + """"; КонецЕсли;
							
	// Маскирование сиволов обрабатываемых JavaScript-ом не правильно.
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
						Символ(127),	"\u007f"),
						Символ(128),	"\u0080"),
						Символ(129),	"\u0081"),
						Символ(130),	"\u0082"),
						Символ(131),	"\u0083"),
						Символ(132),	"\u0084"),
						Символ(133),	"\u0085"),
						Символ(134),	"\u0086"),
						Символ(135),	"\u0087"),
						Символ(136),	"\u0088"),
						Символ(137),	"\u0089"),
						Символ(138),	"\u008a"),
						Символ(139),	"\u008b"),
						Символ(140),	"\u008c"),
						Символ(141),	"\u008d"),
						Символ(142),	"\u008e"),
						Символ(143),	"\u008f"),
						Символ(144),	"\u0090"),
						Символ(145),	"\u0091"),
						Символ(146),	"\u0092"),
						Символ(147),	"\u0093"),
						Символ(148),	"\u0094"),
						Символ(149),	"\u0095"),
						Символ(150),	"\u0096"),
						Символ(151),	"\u0097"),
						Символ(152),	"\u0098"),
						Символ(153),	"\u0099"),
						Символ(154),	"\u009a"),
						Символ(155),	"\u009b"),
						Символ(156),	"\u009c"),
						Символ(157),	"\u009d"),
						Символ(158),	"\u009e"),
						Символ(159),	"\u009f"),
						Символ(173),	"\u00ad");
						
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
						Символ(1536),	"\u0600"),
						Символ(1537),	"\u0601"),
						Символ(1538),	"\u0602"),
						Символ(1539),	"\u0603"),
						Символ(1540),	"\u0604"),
						Символ(1807),	"\u070f"),
						Символ(6068),	"\u17b4"),
						Символ(6069),	"\u17b5"),
						Символ(8204),	"\u200c"),
						Символ(8205),	"\u200d"),
						Символ(8206),	"\u200e"),
						Символ(8207),	"\u200f"),
						Символ(8232),	"\u2028"),
						Символ(8233),	"\u2029"),
						Символ(8234),	"\u202a"),
						Символ(8235),	"\u202b"),
						Символ(8236),	"\u202c"),
						Символ(8237),	"\u202d"),
						Символ(8238),	"\u202e"),
						Символ(8239),	"\u202f"),
						Символ(8288),	"\u2060"),
						Символ(8289),	"\u2061"),
						Символ(8290),	"\u2062"),
						Символ(8291),	"\u2063"),
						Символ(8292),	"\u2064"),
						Символ(8293),	"\u2065"),
						Символ(8294),	"\u2066"),
						Символ(8295),	"\u2067");
						
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
						Символ(8296),	"\u2068"),
						Символ(8297),	"\u2069"),
						Символ(8268),	"\u206a"),
						Символ(8299),	"\u206b"),
						Символ(8300),	"\u206c"),
						Символ(8301),	"\u206d"),
						Символ(8302),	"\u206e"),
						Символ(8303),	"\u206f"),
						Символ(65279),	"\ufeff"),
						Символ(65520),	"\ufff0"),
						Символ(65521),	"\ufff1"),
						Символ(65522),	"\ufff2"),
						Символ(65523),	"\ufff3"),
						Символ(65524),	"\ufff4"),
						Символ(65525),	"\ufff5"),
						Символ(65526),	"\ufff6"),
						Символ(65527),	"\ufff7"),
						Символ(65528),	"\ufff8"),
						Символ(65529),	"\ufff9"),
						Символ(65530),	"\ufffa"),
						Символ(65531),	"\ufffb"),
						Символ(65532),	"\ufffc"),
						Символ(65533),	"\ufffd"),
						Символ(65534),	"\ufffe"),
						Символ(65535),	"\uffff");
						
	// Кавычки.
	Возврат """" + Результат + """";
	
КонецФункции // jsonЗаписатьСтроку()

Функция jsonЗаписатьСсылку(Значение, Стандарт, ПредставленияСсылок, Типы, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов, Перечисление)
	
	// Идентификатор.
	Если Стандарт Тогда 
		Если Перечисление Тогда Идентификатор = Лев(Прав(ЗначениеВСтрокуВнутр(Значение), 33), 32); Идентификатор = Прав(Идентификатор, 8) + "-" + Сред(Идентификатор, 21, 4) + "-" + Сред(Идентификатор, 17, 4) + "-" + Лев(Идентификатор, 4) + "-" + Сред(Идентификатор, 5, 12); Иначе Идентификатор = XMLСтрока(Значение); КонецЕсли;
	Иначе 
		Идентификатор = ЗначениеВСтрокуВнутр(Значение); Идентификатор = "¦ref¦" + СтрЗаменить(СтрЗаменить(Сред(Идентификатор, 6, СтрДлина(Идентификатор) - 6), ":", "×"), ",", "÷") + "¦";
	КонецЕсли;
	
	// Включая представление ссылки.
	Если ПредставленияСсылок Тогда Возврат jsonЗаписать(Новый Структура("Ссылка,Представление", Идентификатор, Строка(Значение)), Стандарт, ПредставленияСсылок, Типы, Неопределено, Смещение, Отступ, ПереносСтроки, НеПолноеМаскированиеСимволов); КонецЕсли;
	
	// Ссылка.
	Возврат """" + Идентификатор + """";
	
КонецФункции // jsonЗаписатьСсылку()


//////////////////

Функция Шаблон(Строка, Параметры) Экспорт
	
	Результат = Строка;
		
	Для Каждого Параметр Из Параметры Цикл
		Результат = СтрЗаменить(Результат, "[" + Параметр.Ключ + "]", Строка(Параметр.Значение));
	КонецЦикла;

	Возврат Результат;
	
КонецФункции // Шаблон()


Функция ИсключениеПустойПакетДанных() Экспорт 
	
	Возврат НСтр("ru = 'JSON: Пустой пакет данных.'; uk = 'JSON: Порожній пакет даних.'");

КонецФункции // ИсключениеНеожиданноеОкончаниеСтроки()

Функция ИсключениеНекорректныйПакетДанных(Индекс) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Некорректный пакет данных в позиции [Индекс].'; uk = 'JSON: Некоректний пакет даних у позиції [Индекс].'"),
				   Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНекорректныйПакетДанных()

Функция ИсключениеНеожиданноеОкончаниеПакетаДанных() Экспорт 
	
	Возврат НСтр("ru = 'JSON: Неожиданное окончание пакета данных.'; uk = 'JSON: Несподіване закінчення пакета даних.'");

КонецФункции // ИсключениеНеожиданноеОкончаниеПакетаДанных()

Функция ИсключениеНеожиданноеОкончаниеМассива(Индекс) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Неожиданное окончание массива в позиции [Индекс].'; uk = 'JSON: Несподіване закінчення масиву у позиції [Индекс].'"),
				   Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНеожиданноеОкончаниеМассива()

Функция ИсключениеНеожиданноеОкончаниеОбъетка(Индекс) Экспорт 

	Возврат Шаблон(НСтр("ru = 'JSON: Неожиданное окончание объекта в позиции [Индекс].'; uk = 'JSON: Несподіване закінчення об''єкту у позиції [Индекс].'"),
				   Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНеожиданноеОкончаниеОбъетка()

Функция ИсключениеНекорректныйТипNull(Индекс) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Некорректный тип Null в позиции [Индекс].'; uk = 'JSON: Некоректний тип Null у позиції [Индекс].'"),
				   Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНекорректныйТипNull()

Функция ИсключениеНекорректныйТипБулево(Индекс) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Некорректный тип Булево в позиции [Индекс].'; uk = 'JSON: Некоректний тип Булево у позиції [Индекс].'"),
				   Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНекорректныйТипБулево()

Функция ИсключениеНекорректныйТипНеопределено(Индекс) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Некорректный тип Неопределено в позиции [Индекс].'; uk = 'JSON: Некоректний тип Невизначено у позиції [Индекс].'"),
				   Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНекорректныйТипНеопределено()

Функция ИсключениеНекорректныйФорматСтроки(Индекс) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Некорректный формат строки в позиции [Индекс].'; uk = 'JSON: Некоректний формат рядка у позиції [Индекс].'"),
				   Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНекорректныйФорматСтроки()

Функция ИсключениеНекорректныйФорматДаты(Индекс, Значение) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Некорректный формат даты [Значение] в позиции [Индекс].'; uk = 'JSON: Некоректний формат дати [Значение] у позиції [Индекс].'"),
				   Новый Структура("Индекс", Индекс, Символ(034) + Значение + Символ(034)));

КонецФункции // ИсключениеНекорректныйФорматДаты()

Функция ИсключениеНекорректныйФорматЧисла(Индекс, Значение) Экспорт 
	
	Если ПустаяСтрока(Значение) Тогда
		
		Возврат Шаблон(НСтр("ru = 'JSON: Неверный формат данных в позиции [Индекс].'; uk = 'JSON: Невірний формат даних у позиції [Индекс].'"),
					   Новый Структура("Индекс", Индекс));

	Иначе
		
		Возврат Шаблон(НСтр("ru = 'JSON: Некорректный формат числа [Значение] в позиции [Индекс].'; uk = 'JSON: Некоректний формат числа [Значение] у позиції [Индекс].'"),
					   Новый Структура("Индекс,Значение", Индекс, Символ(034) + Значение + Символ(034)));
					   
	КонецЕсли;
					   
КонецФункции // ИсключениеНекорректныйФорматЧисла()

Функция ИсключениеНедопустимыйСимвол(Индекс, Символ) Экспорт 
	
	Если (Символ = Неопределено) Тогда
		
		Возврат Шаблон(НСтр("ru = 'JSON: Недопустимый символ в позиции [Индекс].'; uk = 'JSON: Неприпустимий символ в позиції [Индекс].'"),
					   Новый Структура("Индекс", Индекс));

	Иначе
		
		Возврат Шаблон(НСтр("ru = 'JSON: Недопустимый символ в позиции [Индекс], ожидается [Символ].'; uk = 'JSON: Неприпустимий символ в позиції [Индекс], очікується [Символ].'"),
					   Новый Структура("Индекс,Символ", Индекс, Символ(034) + Символ + Символ(034)));

	КонецЕсли;
				   
КонецФункции // ИсключениеНедопустимыйСимвол()

Функция ИсключениеНеопознанныйТип(Индекс, Тип) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Недопустимый тип [Тип] в позиции [Индекс].'; uk = 'JSON: Неприпустимий тип [Тип] у позиції [Индекс].'"),
				   Новый Структура("Индекс,Тип", Индекс, Символ(034) + Тип + Символ(034)));

КонецФункции // ИсключениеНеопознанныйТип()

Функция ИсключениеНевозможноПреобразоватьЗначение(Индекс, Значение) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Невозможно преобразовать значение [Значение] в позиции [Индекс].'; uk = 'JSON: Неможливо перетворити значення [Значение] у позиції [Индекс].'"),
				   Новый Структура("Индекс,Значение", Индекс, Символ(034) + Значение + Символ(034)));

КонецФункции // ИсключениеНевозможноПреобразоватьЗначение()

Функция ИсключениеНевозможноПреобразоватьЗначениеНаКлиенте(Индекс, Значение) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Невозможно на клиенте преобразовать значение [Значение] в позиции [Индекс].'; uk = 'JSON: Неможливо на клієнті перетворити значення [Значение] у позиції [Индекс].'"),
				   Новый Структура("Индекс,Значение", Индекс, Символ(034) + Значение + Символ(034)));

КонецФункции // ИсключениеНевозможноПреобразоватьЗначениеНаКлиенте()


Функция ИсключениеНекорректныйПараметр(Параметр) Экспорт 
	
	Возврат Шаблон(НСтр("ru = 'JSON: Недопустимое значение параметра [Параметр].'; uk = 'JSON: Неприпустиме значення параметра [Параметр].'"),
				   Новый Структура("Параметр", Символ(034) + Параметр+ Символ(034)));

КонецФункции // ИсключениеНекорректныйПараметр()


Функция ИсключениеНедопустимыйТипКлюча(Индекс, Значение) Экспорт 
	
	Если (Индекс = Неопределено) Тогда
		
		Возврат Шаблон(НСтр("ru = 'JSON: Недопустимый тип значения ключа [Тип].'; uk = 'JSON: Неприпустимий тип значення ключа [Тип].'"),
					   Новый Структура("Тип", ТипЗнч(Значение)));

	Иначе
		
		Возврат Шаблон(НСтр("ru = 'JSON: Недопустимый тип значения ключа [Тип] в позиции [Индекс].'; uk = 'JSON: Неприпустимий тип значення ключа [Тип] в позиції [Индекс].'"),
					   Новый Структура("Индекс,Тип", Индекс, Символ(034) + ТипЗнч(Значение) + Символ(034)));

	КонецЕсли;

КонецФункции // ИсключениеНедопустимыйТипКлюча()

Функция ИсключениеНевозможноВыполнитьЗапрос(Описание) Экспорт 
	
	Позиция = Найти(Описание, "}: "); Если Булево(Позиция) Тогда Позиция = Позиция + 3; Иначе Позиция = 1; КонецЕсли;
	Длина = Найти(Описание, Символы.ПС); Если Булево(Длина) Тогда Длина = Длина - Позиция; Иначе Длина = СтрДлина(Описание); КонецЕсли;
	Возврат НСтр("ru = 'JSON: Невозможно выполнить запрос. '; uk = 'JSON: Неможливо виконати запит. '") + Сред(Описание, Позиция, Длина) + ".";

КонецФункции // ИсключениеНевозможноВыполнитьЗапрос()

#КонецОбласти

// © Все права на распространение и модификацию модуля принадлежат ООО "АКИП" (www.akitorg.ru)